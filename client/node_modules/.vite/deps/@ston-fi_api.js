import "./chunk-2TUXWMP5.js";

// node_modules/@ston-fi/api/dist/esm/chunk-7A4COZMT.js
var AssetKind = {
  Ton: "Ton",
  Wton: "Wton",
  Jetton: "Jetton"
};
var AssetTag = {
  Essential: "asset:essential",
  Blacklisted: "asset:blacklisted",
  Deprecated: "asset:deprecated",
  DefaultSymbol: "asset:default_symbol",
  LiquidityNo: "asset:liquidity:no",
  LiquidityMedium: "asset:liquidity:medium",
  LiquidityLow: "asset:liquidity:low",
  LiquidityHigh: "asset:liquidity:high",
  LiquidityVeryHigh: "asset:liquidity:very_high",
  Popular: "asset:popular",
  WalletHasBalance: "asset:wallet_has_balance",
  WalletHasLiquidityInPool: "asset:wallet_has_liquidity_in_pool",
  Taxable: "asset:taxable",
  /** @deprecated use LiquidityNo instead */
  NoLiquidity: "no_liquidity",
  /** @deprecated use LiquidityLow instead */
  LowLiquidity: "low_liquidity",
  /** @deprecated use LiquidityHigh instead */
  HighLiquidity: "high_liquidity"
};

// node_modules/@ston-fi/api/dist/esm/chunk-4FIIYSXL.js
var LiquidityProvisionType = {
  /**
   * Create new pool (requires both token amounts)
   */
  Initial: "Initial",
  /**
   * Add to existing pool at current ratio (auto-calculates one token amount)
   */
  Balanced: "Balanced",
  /**
   * Add liquidity in any ratio to existing pool (requires explicit amounts)
   */
  Arbitrary: "Arbitrary"
};

// node_modules/@ston-fi/api/dist/esm/chunk-JU4RZJS5.js
var OperationType = {
  Swap: "Swap",
  SendLiquidity: "SendLiquidity",
  RefundLiquidity: "RefundLiquidity",
  AddLiquidity: "AddLiquidity",
  WithdrawLiquidity: "WithdrawLiquidity",
  SetFees: "SetFees",
  CollectFees: "CollectFees",
  ResetGas: "ResetGas"
};

// node_modules/@ston-fi/api/dist/esm/chunk-SQI6UOGU.js
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache3) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache3) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache3) {
    const item = cache3.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
    return this;
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i = items.length - 1; i >= 0; --i) {
      const item = items[i];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// node_modules/@ston-fi/api/dist/esm/chunk-OAIRL2FN.js
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@ston-fi/api/dist/esm/chunk-RWCFPGFX.js
var isObject = (value) => typeof value === "object" && value !== null;
var isObjectCustom = (value) => isObject(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var mapObjectSkip = Symbol("mapObjectSkip");
var _mapObject = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
  options = __spreadValues({
    deep: false,
    target: {}
  }, options);
  if (isSeen.has(object)) {
    return isSeen.get(object);
  }
  isSeen.set(object, options.target);
  const { target } = options;
  delete options.target;
  const mapArray = (array) => array.map((element) => isObjectCustom(element) ? _mapObject(element, mapper, options, isSeen) : element);
  if (Array.isArray(object)) {
    return mapArray(object);
  }
  for (const [key, value] of Object.entries(object)) {
    const mapResult = mapper(key, value, object);
    if (mapResult === mapObjectSkip) {
      continue;
    }
    let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
    if (newKey === "__proto__") {
      continue;
    }
    if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
      newValue = Array.isArray(newValue) ? mapArray(newValue) : _mapObject(newValue, mapper, options, isSeen);
    }
    target[newKey] = newValue;
  }
  return target;
};
function mapObject(object, mapper, options) {
  if (!isObject(object)) {
    throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
  }
  return _mapObject(object, mapper, options);
}
var UPPERCASE = /[\p{Lu}]/u;
var LOWERCASE = /[\p{Ll}]/u;
var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
var SEPARATORS = /[_.\- ]+/;
var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
var preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase2) => {
  let isLastCharLower = false;
  let isLastCharUpper = false;
  let isLastLastCharUpper = false;
  let isLastLastCharPreserved = false;
  for (let index = 0; index < string.length; index++) {
    const character = string[index];
    isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
    if (isLastCharLower && UPPERCASE.test(character)) {
      string = string.slice(0, index) + "-" + string.slice(index);
      isLastCharLower = false;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = true;
      index++;
    } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character) && (!isLastLastCharPreserved || preserveConsecutiveUppercase2)) {
      string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = false;
      isLastCharLower = true;
    } else {
      isLastCharLower = toLowerCase(character) === character && toUpperCase(character) !== character;
      isLastLastCharUpper = isLastCharUpper;
      isLastCharUpper = toUpperCase(character) === character && toLowerCase(character) !== character;
    }
  }
  return string;
};
var preserveConsecutiveUppercase = (input, toLowerCase) => {
  LEADING_CAPITAL.lastIndex = 0;
  return input.replaceAll(LEADING_CAPITAL, (match) => toLowerCase(match));
};
var postProcess = (input, toUpperCase) => {
  SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
  NUMBERS_AND_IDENTIFIER.lastIndex = 0;
  return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match, pattern, offset) => ["_", "-"].includes(input.charAt(offset + match.length)) ? match : toUpperCase(match)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier) => toUpperCase(identifier));
};
function camelCase(input, options) {
  if (!(typeof input === "string" || Array.isArray(input))) {
    throw new TypeError("Expected the input to be `string | string[]`");
  }
  options = __spreadValues({
    pascalCase: false,
    preserveConsecutiveUppercase: false
  }, options);
  if (Array.isArray(input)) {
    input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
  } else {
    input = input.trim();
  }
  if (input.length === 0) {
    return "";
  }
  const toLowerCase = options.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options.locale);
  const toUpperCase = options.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options.locale);
  if (input.length === 1) {
    if (SEPARATORS.test(input)) {
      return "";
    }
    return options.pascalCase ? toUpperCase(input) : toLowerCase(input);
  }
  const hasUpperCase = input !== toLowerCase(input);
  if (hasUpperCase) {
    input = preserveCamelCase(input, toLowerCase, toUpperCase, options.preserveConsecutiveUppercase);
  }
  input = input.replace(LEADING_SEPARATORS, "");
  input = options.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
  if (options.pascalCase) {
    input = toUpperCase(input.charAt(0)) + input.slice(1);
  }
  return postProcess(input, toUpperCase);
}
var has = (array, key) => array.some((element) => {
  if (typeof element === "string") {
    return element === key;
  }
  element.lastIndex = 0;
  return element.test(key);
});
var cache = new QuickLRU({ maxSize: 1e5 });
var isObject2 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var transform = (input, options = {}) => {
  if (!isObject2(input)) {
    return input;
  }
  const {
    exclude,
    pascalCase = false,
    stopPaths,
    deep = false,
    preserveConsecutiveUppercase: preserveConsecutiveUppercase2 = false
  } = options;
  const stopPathsSet = new Set(stopPaths);
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject2(value)) {
      const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      if (!stopPathsSet.has(path)) {
        value = mapObject(value, makeMapper(path));
      }
    }
    if (!(exclude && has(exclude, key))) {
      const cacheKey = pascalCase ? `${key}_` : key;
      if (cache.has(cacheKey)) {
        key = cache.get(cacheKey);
      } else {
        const returnValue = camelCase(key, { pascalCase, locale: false, preserveConsecutiveUppercase: preserveConsecutiveUppercase2 });
        if (key.length < 100) {
          cache.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return mapObject(input, makeMapper(void 0));
};
function camelcaseKeys(input, options) {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => transform(input[key], options));
  }
  return transform(input, options);
}
function camelcaseKeys2(val) {
  return camelcaseKeys(val, { deep: true });
}

// node_modules/@ston-fi/api/dist/esm/chunk-5T2DJ3WD.js
function denullifyValues(obj) {
  const newObj = {};
  for (const k in obj) {
    const v = obj[k];
    newObj[k] = v === null ? void 0 : v && typeof v === "object" && v.__proto__.constructor === Object ? denullifyValues(v) : v;
  }
  return newObj;
}

// node_modules/@ston-fi/api/dist/esm/chunk-E7NKSECV.js
function normalizeResponse(response) {
  return denullifyValues(camelcaseKeys2(response));
}

// node_modules/@ston-fi/api/dist/esm/chunk-OG3WA5MF.js
var normalizeDate = (date) => {
  return date.toISOString().split(".")[0];
};

// node_modules/@ston-fi/api/dist/esm/chunk-A4P3E7XZ.js
var require_map_obj = __commonJS({
  "node_modules/.pnpm/map-obj@4.3.0/node_modules/map-obj/index.js"(exports, module) {
    "use strict";
    var isObject22 = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip2 = Symbol("skip");
    var isObjectCustom2 = (value) => isObject22(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject2 = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = __spreadValues({
        deep: false,
        target: {}
      }, options);
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom2(element) ? mapObject2(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip2) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom2(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject2(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module.exports = (object, mapper, options) => {
      if (!isObject22(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject2(object, mapper, options);
    };
    module.exports.mapObjectSkip = mapObjectSkip2;
  }
});
var import_map_obj = __toESM(require_map_obj(), 1);
var handlePreserveConsecutiveUppercase = (decamelized, separator) => {
  decamelized = decamelized.replace(
    new RegExp("((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))", "gu"),
    ($0) => $0.toLowerCase()
  );
  return decamelized.replace(
    new RegExp("(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    (_, $1, $2) => $1 + separator + $2.toLowerCase()
  );
};
function decamelize(text, {
  separator = "_",
  preserveConsecutiveUppercase: preserveConsecutiveUppercase2 = false
} = {}) {
  if (!(typeof text === "string" && typeof separator === "string")) {
    throw new TypeError(
      "The `text` and `separator` arguments should be of type `string`"
    );
  }
  if (text.length < 2) {
    return preserveConsecutiveUppercase2 ? text : text.toLowerCase();
  }
  const replacement = `$1${separator}$2`;
  const decamelized = text.replace(
    new RegExp("([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})", "gu"),
    replacement
  );
  if (preserveConsecutiveUppercase2) {
    return handlePreserveConsecutiveUppercase(decamelized, separator);
  }
  return decamelized.replace(
    new RegExp("(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    replacement
  ).toLowerCase();
}
var has2 = (array, key) => array.some((element) => {
  if (typeof element === "string") {
    return element === key;
  }
  element.lastIndex = 0;
  return element.test(key);
});
var cache2 = new QuickLRU({ maxSize: 1e5 });
var isObject3 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var transform2 = (input, options = {}) => {
  if (!isObject3(input)) {
    return input;
  }
  const {
    separator = "_",
    exclude,
    deep = false
  } = options;
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject3(value)) {
      const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      value = (0, import_map_obj.default)(value, makeMapper(path));
    }
    if (!(exclude && has2(exclude, key))) {
      const cacheKey = `${separator}${key}`;
      if (cache2.has(cacheKey)) {
        key = cache2.get(cacheKey);
      } else {
        const returnValue = decamelize(key, { separator });
        if (key.length < 100) {
          cache2.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return (0, import_map_obj.default)(input, makeMapper(void 0));
};
function decamelizeKeys(input, options) {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => transform2(input[key], options));
  }
  return transform2(input, options);
}
function decamelizeKeys2(val) {
  return decamelizeKeys(val, { deep: true });
}

// node_modules/@ston-fi/api/dist/esm/chunk-OKU6EODG.js
function toUrlSafe(str) {
  let safeStr = str;
  while (safeStr.indexOf("/") >= 0) {
    safeStr = safeStr.replace("/", "_");
  }
  while (safeStr.indexOf("+") >= 0) {
    safeStr = safeStr.replace("+", "-");
  }
  while (safeStr.indexOf("=") >= 0) {
    safeStr = safeStr.replace("=", "");
  }
  return safeStr;
}

// node_modules/@ston-fi/api/dist/esm/chunk-KBV5UDV5.js
function normalizeRequest(path, options) {
  const pathWithParams = path.replace(/{([a-zA-Z0-9_]+)}/g, (_, key) => {
    var _a, _b;
    const value = (_a = options == null ? void 0 : options.query) == null ? void 0 : _a[key];
    if (!value) {
      throw new Error(`Missing value for path parameter "${key}"`);
    }
    (_b = options == null ? void 0 : options.query) == null ? true : delete _b[key];
    return toUrlSafe(value);
  });
  if (options == null ? void 0 : options.query) {
    for (const key in options.query) {
      const value = options.query[key];
      if (typeof value === "string") {
        options.query[key] = toUrlSafe(value);
      }
    }
    options.query = decamelizeKeys2(options.query);
  }
  return [pathWithParams, options];
}

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
    return value.slice(1, -1);
  }
  const _value = value.trim();
  if (_value.length <= 9) {
    switch (_value.toLowerCase()) {
      case "true": {
        return true;
      }
      case "false": {
        return false;
      }
      case "undefined": {
        return void 0;
      }
      case "null": {
        return null;
      }
      case "nan": {
        return Number.NaN;
      }
      case "infinity": {
        return Number.POSITIVE_INFINITY;
      }
      case "-infinity": {
        return Number.NEGATIVE_INFINITY;
      }
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/ufo/dist/index.mjs
var r = String.fromCharCode;
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var SLASH_RE = /\//g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_CARET_RE = /%5e/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_PIPE_RE = /%7c/gi;
var ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function decode(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join("&");
}
var PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
var PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
var PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
var protocolRelative = Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash;
}

// node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs
var FetchError = class extends Error {
  constructor(message, opts) {
    super(message, opts);
    this.name = "FetchError";
    if ((opts == null ? void 0 : opts.cause) && !this.cause) {
      this.cause = opts.cause;
    }
  }
};
function createFetchError(ctx) {
  var _a, _b, _c, _d, _e;
  const errorMessage = ((_a = ctx.error) == null ? void 0 : _a.message) || ((_b = ctx.error) == null ? void 0 : _b.toString()) || "";
  const method = ((_c = ctx.request) == null ? void 0 : _c.method) || ((_d = ctx.options) == null ? void 0 : _d.method) || "GET";
  const url = ((_e = ctx.request) == null ? void 0 : _e.url) || String(ctx.request) || "/";
  const requestStr = `[${method}] ${JSON.stringify(url)}`;
  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : "<no response>";
  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : ""}`;
  const fetchError = new FetchError(
    message,
    ctx.error ? { cause: ctx.error } : void 0
  );
  for (const key of ["request", "options", "response"]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx[key];
      }
    });
  }
  for (const [key, refKey] of [
    ["data", "_data"],
    ["status", "status"],
    ["statusCode", "status"],
    ["statusText", "statusText"],
    ["statusMessage", "statusText"]
  ]) {
    Object.defineProperty(fetchError, key, {
      get() {
        return ctx.response && ctx.response[refKey];
      }
    });
  }
  return fetchError;
}
var payloadMethods = new Set(
  Object.freeze(["PATCH", "POST", "PUT", "DELETE"])
);
function isPayloadMethod(method = "GET") {
  return payloadMethods.has(method.toUpperCase());
}
function isJSONSerializable(value) {
  if (value === void 0) {
    return false;
  }
  const t = typeof value;
  if (t === "string" || t === "number" || t === "boolean" || t === null) {
    return true;
  }
  if (t !== "object") {
    return false;
  }
  if (Array.isArray(value)) {
    return true;
  }
  if (value.buffer) {
    return false;
  }
  return value.constructor && value.constructor.name === "Object" || typeof value.toJSON === "function";
}
var textTypes = /* @__PURE__ */ new Set([
  "image/svg",
  "application/xml",
  "application/xhtml",
  "application/html"
]);
var JSON_RE = /^application\/(?:[\w!#$%&*.^`~-]*\+)?json(;.+)?$/i;
function detectResponseType(_contentType = "") {
  if (!_contentType) {
    return "json";
  }
  const contentType = _contentType.split(";").shift() || "";
  if (JSON_RE.test(contentType)) {
    return "json";
  }
  if (textTypes.has(contentType) || contentType.startsWith("text/")) {
    return "text";
  }
  return "blob";
}
function resolveFetchOptions(request, input, defaults, Headers2) {
  const headers = mergeHeaders(
    (input == null ? void 0 : input.headers) ?? (request == null ? void 0 : request.headers),
    defaults == null ? void 0 : defaults.headers,
    Headers2
  );
  let query;
  if ((defaults == null ? void 0 : defaults.query) || (defaults == null ? void 0 : defaults.params) || (input == null ? void 0 : input.params) || (input == null ? void 0 : input.query)) {
    query = {
      ...defaults == null ? void 0 : defaults.params,
      ...defaults == null ? void 0 : defaults.query,
      ...input == null ? void 0 : input.params,
      ...input == null ? void 0 : input.query
    };
  }
  return {
    ...defaults,
    ...input,
    query,
    params: query,
    headers
  };
}
function mergeHeaders(input, defaults, Headers2) {
  if (!defaults) {
    return new Headers2(input);
  }
  const headers = new Headers2(defaults);
  if (input) {
    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers2(input)) {
      headers.set(key, value);
    }
  }
  return headers;
}
async function callHooks(context, hooks) {
  if (hooks) {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        await hook(context);
      }
    } else {
      await hooks(context);
    }
  }
}
var retryStatusCodes = /* @__PURE__ */ new Set([
  408,
  // Request Timeout
  409,
  // Conflict
  425,
  // Too Early (Experimental)
  429,
  // Too Many Requests
  500,
  // Internal Server Error
  502,
  // Bad Gateway
  503,
  // Service Unavailable
  504
  // Gateway Timeout
]);
var nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function createFetch(globalOptions = {}) {
  const {
    fetch: fetch2 = globalThis.fetch,
    Headers: Headers2 = globalThis.Headers,
    AbortController: AbortController2 = globalThis.AbortController
  } = globalOptions;
  async function onError(context) {
    const isAbort = context.error && context.error.name === "AbortError" && !context.options.timeout || false;
    if (context.options.retry !== false && !isAbort) {
      let retries;
      if (typeof context.options.retry === "number") {
        retries = context.options.retry;
      } else {
        retries = isPayloadMethod(context.options.method) ? 0 : 1;
      }
      const responseCode = context.response && context.response.status || 500;
      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {
        const retryDelay = typeof context.options.retryDelay === "function" ? context.options.retryDelay(context) : context.options.retryDelay || 0;
        if (retryDelay > 0) {
          await new Promise((resolve) => setTimeout(resolve, retryDelay));
        }
        return $fetchRaw(context.request, {
          ...context.options,
          retry: retries - 1
        });
      }
    }
    const error = createFetchError(context);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(error, $fetchRaw);
    }
    throw error;
  }
  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {
    const context = {
      request: _request,
      options: resolveFetchOptions(
        _request,
        _options,
        globalOptions.defaults,
        Headers2
      ),
      response: void 0,
      error: void 0
    };
    if (context.options.method) {
      context.options.method = context.options.method.toUpperCase();
    }
    if (context.options.onRequest) {
      await callHooks(context, context.options.onRequest);
    }
    if (typeof context.request === "string") {
      if (context.options.baseURL) {
        context.request = withBase(context.request, context.options.baseURL);
      }
      if (context.options.query) {
        context.request = withQuery(context.request, context.options.query);
        delete context.options.query;
      }
      if ("query" in context.options) {
        delete context.options.query;
      }
      if ("params" in context.options) {
        delete context.options.params;
      }
    }
    if (context.options.body && isPayloadMethod(context.options.method)) {
      if (isJSONSerializable(context.options.body)) {
        context.options.body = typeof context.options.body === "string" ? context.options.body : JSON.stringify(context.options.body);
        context.options.headers = new Headers2(context.options.headers || {});
        if (!context.options.headers.has("content-type")) {
          context.options.headers.set("content-type", "application/json");
        }
        if (!context.options.headers.has("accept")) {
          context.options.headers.set("accept", "application/json");
        }
      } else if (
        // ReadableStream Body
        "pipeTo" in context.options.body && typeof context.options.body.pipeTo === "function" || // Node.js Stream Body
        typeof context.options.body.pipe === "function"
      ) {
        if (!("duplex" in context.options)) {
          context.options.duplex = "half";
        }
      }
    }
    let abortTimeout;
    if (!context.options.signal && context.options.timeout) {
      const controller = new AbortController2();
      abortTimeout = setTimeout(() => {
        const error = new Error(
          "[TimeoutError]: The operation was aborted due to timeout"
        );
        error.name = "TimeoutError";
        error.code = 23;
        controller.abort(error);
      }, context.options.timeout);
      context.options.signal = controller.signal;
    }
    try {
      context.response = await fetch2(
        context.request,
        context.options
      );
    } catch (error) {
      context.error = error;
      if (context.options.onRequestError) {
        await callHooks(
          context,
          context.options.onRequestError
        );
      }
      return await onError(context);
    } finally {
      if (abortTimeout) {
        clearTimeout(abortTimeout);
      }
    }
    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324
    // https://github.com/unjs/ofetch/issues/294
    // https://github.com/JakeChampion/fetch/issues/1454
    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== "HEAD";
    if (hasBody) {
      const responseType = (context.options.parseResponse ? "json" : context.options.responseType) || detectResponseType(context.response.headers.get("content-type") || "");
      switch (responseType) {
        case "json": {
          const data = await context.response.text();
          const parseFunction = context.options.parseResponse || destr;
          context.response._data = parseFunction(data);
          break;
        }
        case "stream": {
          context.response._data = context.response.body || context.response._bodyInit;
          break;
        }
        default: {
          context.response._data = await context.response[responseType]();
        }
      }
    }
    if (context.options.onResponse) {
      await callHooks(
        context,
        context.options.onResponse
      );
    }
    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {
      if (context.options.onResponseError) {
        await callHooks(
          context,
          context.options.onResponseError
        );
      }
      return await onError(context);
    }
    return context.response;
  };
  const $fetch = async function $fetch2(request, options) {
    const r2 = await $fetchRaw(request, options);
    return r2._data;
  };
  $fetch.raw = $fetchRaw;
  $fetch.native = (...args) => fetch2(...args);
  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({
    ...globalOptions,
    ...customGlobalOptions,
    defaults: {
      ...globalOptions.defaults,
      ...customGlobalOptions.defaults,
      ...defaultOptions
    }
  });
  return $fetch;
}

// node_modules/ofetch/dist/index.mjs
var _globalThis = function() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}();
var fetch = _globalThis.fetch ? (...args) => _globalThis.fetch(...args) : () => Promise.reject(new Error("[ofetch] global.fetch is not supported!"));
var Headers = _globalThis.Headers;
var AbortController = _globalThis.AbortController;
var ofetch = createFetch({ fetch, Headers, AbortController });

// node_modules/@ston-fi/api/dist/esm/chunk-YBTQQQPM.js
var StonApiClient = class {
  constructor(options) {
    var _a, _b;
    const baseUrl = new URL(
      (_b = (_a = options == null ? void 0 : options.baseURL) != null ? _a : options == null ? void 0 : options.baseUrl) != null ? _b : "https://api.ston.fi"
    );
    const baseQuery = [...new URLSearchParams(baseUrl.search)].reduce(
      // biome-ignore lint/performance/noAccumulatingSpread: it's ok here
      (acc, [key, value]) => __spreadProps(__spreadValues({}, acc), { [key]: value }),
      {}
    );
    this.apiFetch = ofetch.create({
      baseURL: `${baseUrl.origin}${baseUrl.pathname}`,
      query: baseQuery
    });
  }
  getAsset(assetAddress) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/assets/{assetAddress}", {
            method: "GET",
            query: { assetAddress }
          })
        )
      ).asset;
    });
  }
  getAssets() {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/assets", {
            method: "GET"
          })
        )
      ).assetList;
    });
  }
  queryAssets(_a) {
    return __async(this, null, function* () {
      var _b = _a, {
        unconditionalAssets: unconditionalAsset
      } = _b, query = __objRest(_b, [
        "unconditionalAssets"
      ]);
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/assets/query", {
            method: "POST",
            query: __spreadProps(__spreadValues({}, query), {
              unconditionalAsset
            })
          })
        )
      ).assetList;
    });
  }
  searchAssets(_c) {
    return __async(this, null, function* () {
      var _d = _c, {
        unconditionalAssets: unconditionalAsset
      } = _d, query = __objRest(_d, [
        "unconditionalAssets"
      ]);
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/assets/search", {
            method: "POST",
            query: __spreadProps(__spreadValues({}, query), {
              unconditionalAsset
            })
          })
        )
      ).assetList;
    });
  }
  getFarm(farmAddress) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/farms/{farmAddress}", {
            method: "GET",
            query: { farmAddress }
          })
        )
      ).farm;
    });
  }
  getFarms(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/farms", {
            method: "GET",
            query
          })
        )
      ).farmList;
    });
  }
  getFarmsByPool(poolAddress) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/farms_by_pool/{poolAddress}", {
            method: "GET",
            query: { poolAddress }
          })
        )
      ).farmList;
    });
  }
  getSwapPairs(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/markets", {
            method: "GET",
            query
          })
        )
      ).pairs;
    });
  }
  getSwapStatus(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/swap/status", {
            method: "GET",
            query
          })
        )
      );
    });
  }
  getPool(data) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/pools/{poolAddress}", {
            method: "GET",
            query: typeof data === "string" ? { poolAddress: data } : data
          })
        )
      ).pool;
    });
  }
  getPools(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/pools", {
            method: "GET",
            query
          })
        )
      ).poolList;
    });
  }
  getPoolsByAssetPair(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest(
            "/v1/pools/by_market/{asset0Address}/{asset1Address}",
            {
              method: "GET",
              query
            }
          )
        )
      ).poolList;
    });
  }
  queryPools(_e) {
    return __async(this, null, function* () {
      var _f = _e, {
        unconditionalAssets: unconditionalAsset
      } = _f, query = __objRest(_f, [
        "unconditionalAssets"
      ]);
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/pool/query", {
            method: "POST",
            query: __spreadProps(__spreadValues({}, query), {
              unconditionalAsset
            })
          })
        )
      ).poolList;
    });
  }
  simulateSwap(_g) {
    return __async(this, null, function* () {
      var _h = _g, {
        offerUnits: units
      } = _h, query = __objRest(_h, [
        "offerUnits"
      ]);
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/swap/simulate", {
            method: "POST",
            query: __spreadProps(__spreadValues({}, query), {
              units
            })
          })
        )
      );
    });
  }
  simulateReverseSwap(_i) {
    return __async(this, null, function* () {
      var _j = _i, {
        askUnits: units
      } = _j, query = __objRest(_j, [
        "askUnits"
      ]);
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/reverse_swap/simulate", {
            method: "POST",
            query: __spreadProps(__spreadValues({}, query), {
              units
            })
          })
        )
      );
    });
  }
  simulateLiquidityProvision(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/liquidity_provision/simulate", {
            method: "POST",
            query
          })
        )
      );
    });
  }
  getJettonWalletAddress(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/jetton/{jettonAddress}/address", {
            method: "GET",
            query
          })
        )
      ).address;
    });
  }
  getWalletAsset(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest(
            "/v1/wallets/{walletAddress}/assets/{assetAddress}",
            {
              method: "GET",
              query
            }
          )
        )
      ).asset;
    });
  }
  getWalletAssets(walletAddress) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/wallets/{walletAddress}/assets", {
            method: "GET",
            query: { walletAddress }
          })
        )
      ).assetList;
    });
  }
  getWalletFarm(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/wallets/{walletAddress}/farms/{farmAddress}", {
            method: "GET",
            query
          })
        )
      ).farm;
    });
  }
  getWalletFarms(data) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/wallets/{walletAddress}/farms", {
            method: "GET",
            query: typeof data === "string" ? { walletAddress: data } : data
          })
        )
      ).farmList;
    });
  }
  getWalletPool(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/wallets/{walletAddress}/pools/{poolAddress}", {
            method: "GET",
            query
          })
        )
      ).pool;
    });
  }
  getWalletPools(data) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/wallets/{walletAddress}/pools", {
            method: "GET",
            query: typeof data === "string" ? { walletAddress: data } : data
          })
        )
      ).poolList;
    });
  }
  getWalletOperations(_k) {
    return __async(this, null, function* () {
      var _l = _k, {
        since,
        until
      } = _l, query = __objRest(_l, [
        "since",
        "until"
      ]);
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/wallets/{walletAddress}/operations", {
            method: "GET",
            query: __spreadProps(__spreadValues({}, query), {
              since: normalizeDate(since),
              until: normalizeDate(until)
            })
          })
        )
      ).operations;
    });
  }
  getOperations(_0) {
    return __async(this, arguments, function* ({ since, until }) {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/stats/operations", {
            method: "GET",
            query: {
              since: normalizeDate(since),
              until: normalizeDate(until)
            }
          })
        )
      ).operations;
    });
  }
  getRouters(query) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/routers", {
            method: "GET",
            query
          })
        )
      ).routerList;
    });
  }
  getRouter(routerAddress) {
    return __async(this, null, function* () {
      return normalizeResponse(
        yield this.apiFetch(
          ...normalizeRequest("/v1/routers/{routerAddress}", {
            method: "GET",
            query: {
              routerAddress
            }
          })
        )
      ).router;
    });
  }
};
export {
  AssetKind,
  AssetTag,
  LiquidityProvisionType,
  OperationType,
  StonApiClient
};
//# sourceMappingURL=@ston-fi_api.js.map
