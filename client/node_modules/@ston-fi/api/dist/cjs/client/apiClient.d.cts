import { LiquidityProvisionSimulationQuery, LiquidityProvisionType } from './types/liquidityProvision.cjs';
import { AssetTag } from './types/asset.cjs';
import { OperationType } from './types/operation.cjs';

type StonApiClientOptions = {
    baseURL?: string;
    /** @deprecated use `baseURL` instead to better match `FetchOptions` */
    baseUrl?: string;
};
declare class StonApiClient {
    private readonly apiFetch;
    constructor(options?: StonApiClientOptions);
    getAsset(assetAddress: string): Promise<{
        balance?: string | undefined;
        blacklisted: boolean;
        community: boolean;
        contractAddress: string;
        decimals: number;
        defaultSymbol: boolean;
        deprecated: boolean;
        dexPriceUsd?: string | undefined;
        displayName?: string | undefined;
        imageUrl?: string | undefined;
        kind: "Ton" | "Wton" | "Jetton";
        priority: number;
        symbol: string;
        thirdPartyPriceUsd?: string | undefined;
        walletAddress?: string | undefined;
        popularityIndex?: number | undefined;
        tags: AssetTag[];
        customPayloadApiUri?: string | undefined;
        extensions?: string[] | undefined;
    }>;
    getAssets(): Promise<{
        balance?: string | undefined;
        blacklisted: boolean;
        community: boolean;
        contractAddress: string;
        decimals: number;
        defaultSymbol: boolean;
        deprecated: boolean;
        dexPriceUsd?: string | undefined;
        displayName?: string | undefined;
        imageUrl?: string | undefined;
        kind: "Ton" | "Wton" | "Jetton";
        priority: number;
        symbol: string;
        thirdPartyPriceUsd?: string | undefined;
        walletAddress?: string | undefined;
        popularityIndex?: number | undefined;
        tags: AssetTag[];
        customPayloadApiUri?: string | undefined;
        extensions?: string[] | undefined;
    }[]>;
    queryAssets({ unconditionalAssets: unconditionalAsset, ...query }: {
        condition: string;
        walletAddress?: string;
        unconditionalAssets?: string[];
    }): Promise<{
        contractAddress: string;
        kind: "Ton" | "Wton" | "Jetton";
        balance?: string | undefined;
        dexPriceUsd?: string | undefined;
        meta?: {
            decimals?: number | undefined;
            symbol?: string | undefined;
            displayName?: string | undefined;
            imageUrl?: string | undefined;
            customPayloadApiUri?: string | undefined;
        } | undefined;
        pairPriority?: number | undefined;
        popularityIndex?: number | undefined;
        tags?: AssetTag[] | undefined;
        walletAddress?: string | undefined;
        extensions?: string[] | undefined;
    }[]>;
    searchAssets({ unconditionalAssets: unconditionalAsset, ...query }: {
        searchString: string;
        condition: string;
        walletAddress?: string;
        unconditionalAssets?: string[];
        limit?: number;
    }): Promise<{
        contractAddress: string;
        kind: "Ton" | "Wton" | "Jetton";
        balance?: string | undefined;
        dexPriceUsd?: string | undefined;
        meta?: {
            decimals?: number | undefined;
            symbol?: string | undefined;
            displayName?: string | undefined;
            imageUrl?: string | undefined;
            customPayloadApiUri?: string | undefined;
        } | undefined;
        pairPriority?: number | undefined;
        popularityIndex?: number | undefined;
        tags?: AssetTag[] | undefined;
        walletAddress?: string | undefined;
        extensions?: string[] | undefined;
    }[]>;
    getFarm(farmAddress: string): Promise<{
        apy?: string | undefined;
        minStakeDurationS: string;
        minterAddress: string;
        nftInfos: {
            address: string;
            createTimestamp: string;
            minUnstakeTimestamp: string;
            nonclaimedRewards: string;
            rewards: {
                address: string;
                amount: string;
            }[];
            stakedTokens: string;
            status: string;
        }[];
        poolAddress: string;
        rewardTokenAddress: string;
        status: string;
    }>;
    getFarms(query?: {
        /**
         * If true farms for V2 pools will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<{
        apy?: string | undefined;
        minStakeDurationS: string;
        minterAddress: string;
        nftInfos: {
            address: string;
            createTimestamp: string;
            minUnstakeTimestamp: string;
            nonclaimedRewards: string;
            rewards: {
                address: string;
                amount: string;
            }[];
            stakedTokens: string;
            status: string;
        }[];
        poolAddress: string;
        rewardTokenAddress: string;
        status: string;
    }[]>;
    getFarmsByPool(poolAddress: string): Promise<{
        apy?: string | undefined;
        minStakeDurationS: string;
        minterAddress: string;
        nftInfos: {
            address: string;
            createTimestamp: string;
            minUnstakeTimestamp: string;
            nonclaimedRewards: string;
            rewards: {
                address: string;
                amount: string;
            }[];
            stakedTokens: string;
            status: string;
        }[];
        poolAddress: string;
        rewardTokenAddress: string;
        status: string;
    }[]>;
    getSwapPairs(query?: {
        /**
         * If true V2 pool pairs will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<[string, string][]>;
    getSwapStatus(query: {
        routerAddress: string;
        ownerAddress: string;
        queryId: string;
    }): Promise<{
        "@type": "NotFound";
    } | {
        "@type": "Found";
        address: string;
        balanceDeltas: string;
        coins: string;
        exitCode: string;
        logicalTime: string;
        queryId: string;
        txHash: string;
    }>;
    getPool(data: string | {
        poolAddress: string;
    }): Promise<{
        address: string;
        apy1D?: string | undefined;
        apy7D?: string | undefined;
        apy30D?: string | undefined;
        collectedToken0ProtocolFee: string;
        collectedToken1ProtocolFee: string;
        deprecated: boolean;
        lpAccountAddress?: string | undefined;
        lpBalance?: string | undefined;
        lpFee: string;
        lpPriceUsd?: string | undefined;
        lpTotalSupply: string;
        lpTotalSupplyUsd?: string | undefined;
        lpWalletAddress?: string | undefined;
        protocolFee: string;
        protocolFeeAddress: string;
        refFee: string;
        reserve0: string;
        reserve1: string;
        routerAddress: string;
        token0Address: string;
        token0Balance?: string | undefined;
        token1Address: string;
        token1Balance?: string | undefined;
    }>;
    getPools(query?: {
        /**
         * If true V2 pools will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<{
        address: string;
        apy1D?: string | undefined;
        apy7D?: string | undefined;
        apy30D?: string | undefined;
        collectedToken0ProtocolFee: string;
        collectedToken1ProtocolFee: string;
        deprecated: boolean;
        lpAccountAddress?: string | undefined;
        lpBalance?: string | undefined;
        lpFee: string;
        lpPriceUsd?: string | undefined;
        lpTotalSupply: string;
        lpTotalSupplyUsd?: string | undefined;
        lpWalletAddress?: string | undefined;
        protocolFee: string;
        protocolFeeAddress: string;
        refFee: string;
        reserve0: string;
        reserve1: string;
        routerAddress: string;
        token0Address: string;
        token0Balance?: string | undefined;
        token1Address: string;
        token1Balance?: string | undefined;
    }[]>;
    getPoolsByAssetPair(query: {
        asset0Address: string;
        asset1Address: string;
    }): Promise<{
        address: string;
        apy1D?: string | undefined;
        apy7D?: string | undefined;
        apy30D?: string | undefined;
        collectedToken0ProtocolFee: string;
        collectedToken1ProtocolFee: string;
        deprecated: boolean;
        lpAccountAddress?: string | undefined;
        lpBalance?: string | undefined;
        lpFee: string;
        lpPriceUsd?: string | undefined;
        lpTotalSupply: string;
        lpTotalSupplyUsd?: string | undefined;
        lpWalletAddress?: string | undefined;
        protocolFee: string;
        protocolFeeAddress: string;
        refFee: string;
        reserve0: string;
        reserve1: string;
        routerAddress: string;
        token0Address: string;
        token0Balance?: string | undefined;
        token1Address: string;
        token1Balance?: string | undefined;
    }[]>;
    queryPools({ unconditionalAssets: unconditionalAsset, ...query }: {
        condition: string;
        walletAddress?: string;
        unconditionalAssets?: string[];
        /**
         * If true V2 pools will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<{
        address: string;
        apy1D?: string | undefined;
        apy7D?: string | undefined;
        apy30D?: string | undefined;
        collectedToken0ProtocolFee: string;
        collectedToken1ProtocolFee: string;
        deprecated: boolean;
        lpAccountAddress?: string | undefined;
        lpBalance?: string | undefined;
        lpFee: string;
        lpPriceUsd?: string | undefined;
        lpTotalSupply: string;
        lpTotalSupplyUsd?: string | undefined;
        lpWalletAddress?: string | undefined;
        protocolFee: string;
        protocolFeeAddress: string;
        refFee: string;
        reserve0: string;
        reserve1: string;
        routerAddress: string;
        token0Address: string;
        token0Balance?: string | undefined;
        token1Address: string;
        token1Balance?: string | undefined;
    }[]>;
    simulateSwap({ offerUnits: units, ...query }: {
        /** The address of the token we want to sell */
        offerAddress: string;
        /** Number of token units we want to sell */
        offerUnits: string;
        /** The address of the token we want to buy */
        askAddress: string;
        /**
         * The maximum possible difference between the rates that we expect and which will actually be,
         * in fractions (for example, 0.001 is 0.1%)
         *
         * Recommended value is 0.01 (1%)
         */
        slippageTolerance: string;
        /**
         * Referral address
         *
         * @default undefined
         */
        referralAddress?: string;
        /**
         * Referral fee in base points
         *
         * Applies only for dex v2, for v1 is always 10 (0.1%)
         * Applies only if `referralAddress` is set
         * Should be in range [0, 100] BPS
         *
         * @default undefined
         */
        referralFeeBps?: string;
        /**
         * If true V2 pools might be selected for the swap.
         *
         * @default true
         */
        dexV2?: boolean;
        /**
         * Allows to restrict exact DEX version (or multiple) to be used for the swap.
         *
         * @default undefined
         */
        dexVersion?: Array<"1" | 1 | "2" | 2>;
    }): Promise<{
        askAddress: string;
        askJettonWallet: string;
        askUnits: string;
        feeAddress: string;
        feePercent: string;
        feeUnits: string;
        minAskUnits: string;
        offerAddress: string;
        offerJettonWallet: string;
        offerUnits: string;
        poolAddress: string;
        priceImpact: string;
        routerAddress: string;
        slippageTolerance: string;
        swapRate: string;
    }>;
    simulateReverseSwap({ askUnits: units, ...query }: {
        /** The address of the token we want to sell */
        offerAddress: string;
        /** The address of the token we want to buy */
        askAddress: string;
        /** Number of token units we want to buy */
        askUnits: string;
        /**
         * The maximum possible difference between the rates that we expect and which will actually be,
         * in fractions (for example, 0.001 is 0.1%)
         *
         * Recommended value is 0.01 (1%)
         */
        slippageTolerance: string;
        /**
         * Referral address
         *
         * @default undefined
         */
        referralAddress?: string;
        /**
         * Referral fee in base points. Should be in range [0, 100] BPS
         *
         * Applies only if `referralAddress` is set
         * Applies only for dex v2, for v1 is always 10 BPS (0.1%)
         *
         * @default undefined
         */
        referralFeeBps?: string;
        /**
         * If true V2 pools might be selected for the swap.
         *
         * @default true
         */
        dexV2?: boolean;
        /**
         * Allows to restrict exact DEX version (or multiple) to be used for the swap.
         *
         * @default undefined
         */
        dexVersion?: Array<"1" | 1 | "2" | 2>;
    }): Promise<{
        askAddress: string;
        askJettonWallet: string;
        askUnits: string;
        feeAddress: string;
        feePercent: string;
        feeUnits: string;
        minAskUnits: string;
        offerAddress: string;
        offerJettonWallet: string;
        offerUnits: string;
        poolAddress: string;
        priceImpact: string;
        routerAddress: string;
        slippageTolerance: string;
        swapRate: string;
    }>;
    simulateLiquidityProvision(query: LiquidityProvisionSimulationQuery): Promise<{
        provisionType: LiquidityProvisionType;
        routerAddress: string;
        poolAddress: string;
        tokenA: string;
        tokenB: string;
        tokenAUnits: string;
        tokenBUnits: string;
        lpAccountAddress: string;
        lpAccountTokenABalance: string;
        lpAccountTokenBBalance: string;
        estimatedLpUnits: string;
        minLpUnits: string;
        minTokenAUnits: string;
        minTokenBUnits: string;
        lpTotalSupply: string;
    }>;
    getJettonWalletAddress(query: {
        jettonAddress: string;
        ownerAddress: string;
    }): Promise<string>;
    getWalletAsset(query: {
        walletAddress: string;
        assetAddress: string;
    }): Promise<{
        balance?: string | undefined;
        blacklisted: boolean;
        community: boolean;
        contractAddress: string;
        decimals: number;
        defaultSymbol: boolean;
        deprecated: boolean;
        dexPriceUsd?: string | undefined;
        displayName?: string | undefined;
        imageUrl?: string | undefined;
        kind: "Ton" | "Wton" | "Jetton";
        priority: number;
        symbol: string;
        thirdPartyPriceUsd?: string | undefined;
        walletAddress?: string | undefined;
        popularityIndex?: number | undefined;
        tags: AssetTag[];
        customPayloadApiUri?: string | undefined;
        extensions?: string[] | undefined;
    }>;
    getWalletAssets(walletAddress: string): Promise<{
        balance?: string | undefined;
        blacklisted: boolean;
        community: boolean;
        contractAddress: string;
        decimals: number;
        defaultSymbol: boolean;
        deprecated: boolean;
        dexPriceUsd?: string | undefined;
        displayName?: string | undefined;
        imageUrl?: string | undefined;
        kind: "Ton" | "Wton" | "Jetton";
        priority: number;
        symbol: string;
        thirdPartyPriceUsd?: string | undefined;
        walletAddress?: string | undefined;
        popularityIndex?: number | undefined;
        tags: AssetTag[];
        customPayloadApiUri?: string | undefined;
        extensions?: string[] | undefined;
    }[]>;
    getWalletFarm(query: {
        walletAddress: string;
        farmAddress: string;
    }): Promise<{
        apy?: string | undefined;
        minStakeDurationS: string;
        minterAddress: string;
        nftInfos: {
            address: string;
            createTimestamp: string;
            minUnstakeTimestamp: string;
            nonclaimedRewards: string;
            rewards: {
                address: string;
                amount: string;
            }[];
            stakedTokens: string;
            status: string;
        }[];
        poolAddress: string;
        rewardTokenAddress: string;
        status: string;
    }>;
    getWalletFarms(
    /**
     * Wallet address.
     *
     * @deprecated Use object with `walletAddress` property instead.
     */
    data: string | {
        walletAddress: string;
        /**
         * If true farms for V2 pools will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<{
        apy?: string | undefined;
        minStakeDurationS: string;
        minterAddress: string;
        nftInfos: {
            address: string;
            createTimestamp: string;
            minUnstakeTimestamp: string;
            nonclaimedRewards: string;
            rewards: {
                address: string;
                amount: string;
            }[];
            stakedTokens: string;
            status: string;
        }[];
        poolAddress: string;
        rewardTokenAddress: string;
        status: string;
    }[]>;
    getWalletPool(query: {
        walletAddress: string;
        poolAddress: string;
    }): Promise<{
        address: string;
        apy1D?: string | undefined;
        apy7D?: string | undefined;
        apy30D?: string | undefined;
        collectedToken0ProtocolFee: string;
        collectedToken1ProtocolFee: string;
        deprecated: boolean;
        lpAccountAddress?: string | undefined;
        lpBalance?: string | undefined;
        lpFee: string;
        lpPriceUsd?: string | undefined;
        lpTotalSupply: string;
        lpTotalSupplyUsd?: string | undefined;
        lpWalletAddress?: string | undefined;
        protocolFee: string;
        protocolFeeAddress: string;
        refFee: string;
        reserve0: string;
        reserve1: string;
        routerAddress: string;
        token0Address: string;
        token0Balance?: string | undefined;
        token1Address: string;
        token1Balance?: string | undefined;
    }>;
    getWalletPools(
    /**
     * Wallet address.
     *
     * @deprecated Use object with `walletAddress` property instead.
     */
    data: string | {
        walletAddress: string;
        /**
         * If true V2 pools will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<{
        address: string;
        apy1D?: string | undefined;
        apy7D?: string | undefined;
        apy30D?: string | undefined;
        collectedToken0ProtocolFee: string;
        collectedToken1ProtocolFee: string;
        deprecated: boolean;
        lpAccountAddress?: string | undefined;
        lpBalance?: string | undefined;
        lpFee: string;
        lpPriceUsd?: string | undefined;
        lpTotalSupply: string;
        lpTotalSupplyUsd?: string | undefined;
        lpWalletAddress?: string | undefined;
        protocolFee: string;
        protocolFeeAddress: string;
        refFee: string;
        reserve0: string;
        reserve1: string;
        routerAddress: string;
        token0Address: string;
        token0Balance?: string | undefined;
        token1Address: string;
        token1Balance?: string | undefined;
    }[]>;
    getWalletOperations({ since, until, ...query }: {
        since: Date;
        until: Date;
        walletAddress: string;
        /**
         * If true V2 pool operations will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
        opType?: OperationType;
    }): Promise<{
        operation: {
            poolTxHash: string;
            poolAddress: string;
            routerAddress: string;
            poolTxLt: number;
            poolTxTimestamp: string;
            destinationWalletAddress: string;
            operationType: OperationType;
            success: boolean;
            exitCode: string;
            asset0Address: string;
            asset0Amount: string;
            asset0Delta: string;
            asset0Reserve: string;
            asset1Address: string;
            asset1Amount: string;
            asset1Delta: string;
            asset1Reserve: string;
            lpTokenDelta: string;
            lpTokenSupply: string;
            feeAssetAddress: string;
            lpFeeAmount: string;
            protocolFeeAmount: string;
            referralFeeAmount: string;
            walletAddress: string;
            walletTxLt: string;
            walletTxHash: string;
            walletTxTimestamp: string;
            referralAddress?: string | undefined;
        };
        asset0Info: {
            balance?: string | undefined;
            blacklisted: boolean;
            community: boolean;
            contractAddress: string;
            decimals: number;
            defaultSymbol: boolean;
            deprecated: boolean;
            dexPriceUsd?: string | undefined;
            displayName?: string | undefined;
            imageUrl?: string | undefined;
            kind: "Ton" | "Wton" | "Jetton";
            priority: number;
            symbol: string;
            thirdPartyPriceUsd?: string | undefined;
            walletAddress?: string | undefined;
            popularityIndex?: number | undefined;
            tags: AssetTag[];
            customPayloadApiUri?: string | undefined;
            extensions?: string[] | undefined;
        };
        asset1Info: {
            balance?: string | undefined;
            blacklisted: boolean;
            community: boolean;
            contractAddress: string;
            decimals: number;
            defaultSymbol: boolean;
            deprecated: boolean;
            dexPriceUsd?: string | undefined;
            displayName?: string | undefined;
            imageUrl?: string | undefined;
            kind: "Ton" | "Wton" | "Jetton";
            priority: number;
            symbol: string;
            thirdPartyPriceUsd?: string | undefined;
            walletAddress?: string | undefined;
            popularityIndex?: number | undefined;
            tags: AssetTag[];
            customPayloadApiUri?: string | undefined;
            extensions?: string[] | undefined;
        };
    }[]>;
    getOperations({ since, until }: {
        since: Date;
        until: Date;
    }): Promise<{
        operation: {
            poolTxHash: string;
            poolAddress: string;
            routerAddress: string;
            poolTxLt: number;
            poolTxTimestamp: string;
            destinationWalletAddress: string;
            operationType: OperationType;
            success: boolean;
            exitCode: string;
            asset0Address: string;
            asset0Amount: string;
            asset0Delta: string;
            asset0Reserve: string;
            asset1Address: string;
            asset1Amount: string;
            asset1Delta: string;
            asset1Reserve: string;
            lpTokenDelta: string;
            lpTokenSupply: string;
            feeAssetAddress: string;
            lpFeeAmount: string;
            protocolFeeAmount: string;
            referralFeeAmount: string;
            walletAddress: string;
            walletTxLt: string;
            walletTxHash: string;
            walletTxTimestamp: string;
            referralAddress?: string | undefined;
        };
        asset0Info: {
            balance?: string | undefined;
            blacklisted: boolean;
            community: boolean;
            contractAddress: string;
            decimals: number;
            defaultSymbol: boolean;
            deprecated: boolean;
            dexPriceUsd?: string | undefined;
            displayName?: string | undefined;
            imageUrl?: string | undefined;
            kind: "Ton" | "Wton" | "Jetton";
            priority: number;
            symbol: string;
            thirdPartyPriceUsd?: string | undefined;
            walletAddress?: string | undefined;
            popularityIndex?: number | undefined;
            tags: AssetTag[];
            customPayloadApiUri?: string | undefined;
            extensions?: string[] | undefined;
        };
        asset1Info: {
            balance?: string | undefined;
            blacklisted: boolean;
            community: boolean;
            contractAddress: string;
            decimals: number;
            defaultSymbol: boolean;
            deprecated: boolean;
            dexPriceUsd?: string | undefined;
            displayName?: string | undefined;
            imageUrl?: string | undefined;
            kind: "Ton" | "Wton" | "Jetton";
            priority: number;
            symbol: string;
            thirdPartyPriceUsd?: string | undefined;
            walletAddress?: string | undefined;
            popularityIndex?: number | undefined;
            tags: AssetTag[];
            customPayloadApiUri?: string | undefined;
            extensions?: string[] | undefined;
        };
    }[]>;
    getRouters(query?: {
        /**
         * If true V2 routers will be present in the response.
         *
         * @default true
         */
        dexV2?: boolean;
    }): Promise<{
        address: string;
        majorVersion: number;
        minorVersion: number;
        ptonMasterAddress: string;
        ptonVersion: string;
        ptonWalletAddress: string;
        routerType: string;
        poolCreationEnabled: boolean;
    }[]>;
    getRouter(routerAddress: string): Promise<{
        address: string;
        majorVersion: number;
        minorVersion: number;
        ptonMasterAddress: string;
        ptonVersion: string;
        ptonWalletAddress: string;
        routerType: string;
        poolCreationEnabled: boolean;
    }>;
}

export { StonApiClient, type StonApiClientOptions };
