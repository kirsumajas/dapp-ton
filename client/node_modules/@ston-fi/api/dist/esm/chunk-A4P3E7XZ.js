import {
  QuickLRU
} from "./chunk-SQI6UOGU.js";
import {
  __commonJS,
  __spreadValues,
  __toESM
} from "./chunk-OAIRL2FN.js";

// node_modules/.pnpm/map-obj@4.3.0/node_modules/map-obj/index.js
var require_map_obj = __commonJS({
  "node_modules/.pnpm/map-obj@4.3.0/node_modules/map-obj/index.js"(exports, module) {
    "use strict";
    var isObject2 = (value) => typeof value === "object" && value !== null;
    var mapObjectSkip = Symbol("skip");
    var isObjectCustom = (value) => isObject2(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
    var mapObject2 = (object, mapper, options, isSeen = /* @__PURE__ */ new WeakMap()) => {
      options = __spreadValues({
        deep: false,
        target: {}
      }, options);
      if (isSeen.has(object)) {
        return isSeen.get(object);
      }
      isSeen.set(object, options.target);
      const { target } = options;
      delete options.target;
      const mapArray = (array) => array.map((element) => isObjectCustom(element) ? mapObject2(element, mapper, options, isSeen) : element);
      if (Array.isArray(object)) {
        return mapArray(object);
      }
      for (const [key, value] of Object.entries(object)) {
        const mapResult = mapper(key, value, object);
        if (mapResult === mapObjectSkip) {
          continue;
        }
        let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
        if (newKey === "__proto__") {
          continue;
        }
        if (options.deep && shouldRecurse && isObjectCustom(newValue)) {
          newValue = Array.isArray(newValue) ? mapArray(newValue) : mapObject2(newValue, mapper, options, isSeen);
        }
        target[newKey] = newValue;
      }
      return target;
    };
    module.exports = (object, mapper, options) => {
      if (!isObject2(object)) {
        throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
      }
      return mapObject2(object, mapper, options);
    };
    module.exports.mapObjectSkip = mapObjectSkip;
  }
});

// node_modules/.pnpm/decamelize-keys@2.0.1/node_modules/decamelize-keys/index.js
var import_map_obj = __toESM(require_map_obj(), 1);

// node_modules/.pnpm/decamelize@6.0.0/node_modules/decamelize/index.js
var handlePreserveConsecutiveUppercase = (decamelized, separator) => {
  decamelized = decamelized.replace(
    new RegExp("((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))", "gu"),
    ($0) => $0.toLowerCase()
  );
  return decamelized.replace(
    new RegExp("(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    (_, $1, $2) => $1 + separator + $2.toLowerCase()
  );
};
function decamelize(text, {
  separator = "_",
  preserveConsecutiveUppercase = false
} = {}) {
  if (!(typeof text === "string" && typeof separator === "string")) {
    throw new TypeError(
      "The `text` and `separator` arguments should be of type `string`"
    );
  }
  if (text.length < 2) {
    return preserveConsecutiveUppercase ? text : text.toLowerCase();
  }
  const replacement = `$1${separator}$2`;
  const decamelized = text.replace(
    new RegExp("([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})", "gu"),
    replacement
  );
  if (preserveConsecutiveUppercase) {
    return handlePreserveConsecutiveUppercase(decamelized, separator);
  }
  return decamelized.replace(
    new RegExp("(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)", "gu"),
    replacement
  ).toLowerCase();
}

// node_modules/.pnpm/decamelize-keys@2.0.1/node_modules/decamelize-keys/index.js
var has = (array, key) => array.some((element) => {
  if (typeof element === "string") {
    return element === key;
  }
  element.lastIndex = 0;
  return element.test(key);
});
var cache = new QuickLRU({ maxSize: 1e5 });
var isObject = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
var transform = (input, options = {}) => {
  if (!isObject(input)) {
    return input;
  }
  const {
    separator = "_",
    exclude,
    deep = false
  } = options;
  const makeMapper = (parentPath) => (key, value) => {
    if (deep && isObject(value)) {
      const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
      value = (0, import_map_obj.default)(value, makeMapper(path));
    }
    if (!(exclude && has(exclude, key))) {
      const cacheKey = `${separator}${key}`;
      if (cache.has(cacheKey)) {
        key = cache.get(cacheKey);
      } else {
        const returnValue = decamelize(key, { separator });
        if (key.length < 100) {
          cache.set(cacheKey, returnValue);
        }
        key = returnValue;
      }
    }
    return [key, value];
  };
  return (0, import_map_obj.default)(input, makeMapper(void 0));
};
function decamelizeKeys(input, options) {
  if (Array.isArray(input)) {
    return Object.keys(input).map((key) => transform(input[key], options));
  }
  return transform(input, options);
}

// src/utils/decamelizeKeys.ts
function decamelizeKeys2(val) {
  return decamelizeKeys(val, { deep: true });
}

export {
  decamelizeKeys2 as decamelizeKeys
};
//# sourceMappingURL=chunk-A4P3E7XZ.js.map