"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } async function _asyncOptionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = await fn(value); } else if (op === 'call' || op === 'optionalCall') { value = await fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkKMDPQX63cjs = require('./chunk-KMDPQX63.cjs');



var _chunkJLYOJWE3cjs = require('./chunk-JLYOJWE3.cjs');


var _chunkIIMQROIVcjs = require('./chunk-IIMQROIV.cjs');


var _chunk3ATZT4MWcjs = require('./chunk-3ATZT4MW.cjs');

// src/contracts/farm/v3/FarmNftItemV3.ts




var _ton = require('@ton/ton');
var FarmNftItemV3 = (_class = class _FarmNftItemV3 extends _chunkIIMQROIVcjs.Contract {
  static __initStatic() {this.version = _chunkJLYOJWE3cjs.FARM_VERSION.v3}
  static __initStatic2() {this.gasConstants = {
    claimRewardsBase: _ton.toNano.call(void 0, "0.35"),
    claimRewardsPerPool: _ton.toNano.call(void 0, "0.13"),
    unstakeBase: _ton.toNano.call(void 0, "0.45"),
    unstakePerPool: _ton.toNano.call(void 0, "0.13"),
    destroy: _ton.toNano.call(void 0, "0.05")
  }}
  
  constructor(address, { gasConstants, ...options } = {}) {
    super(address, options);
    this.gasConstants = {
      ..._FarmNftItemV3.gasConstants,
      ...gasConstants
    };
  }
  async createClaimRewardsBody(params) {
    const builder = _ton.beginCell.call(void 0, );
    builder.storeUint(_chunkJLYOJWE3cjs.FARM_OP_CODES.CLAIM_REWARDS, 32);
    builder.storeUint(_nullishCoalesce(params.queryId, () => ( 0)), 64);
    if (params.claimAll) {
      builder.storeUint(1, 1);
      builder.storeUint(0, 8);
    } else {
      builder.storeUint(0, 1);
      builder.storeUint(params.poolIndex, 8);
    }
    return builder.endCell();
  }
  /**
   * Build all data required to execute a `claim_rewards` transaction.
   *
   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain
   * @param {number | undefined} params.poolIndex - Optional; farm reward pool index used for claiming; If undefined claim rewards from all pools
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} all data required to execute a `claim_rewards` transaction.
   */
  async getClaimRewardsTxParams(provider, params) {
    const to = this.address;
    const body = await this.createClaimRewardsBody({
      queryId: _optionalChain([params, 'optionalAccess', _ => _.queryId]),
      claimAll: _optionalChain([params, 'optionalAccess', _2 => _2.poolIndex]) === void 0,
      poolIndex: _nullishCoalesce(_optionalChain([params, 'optionalAccess', _3 => _3.poolIndex]), () => ( 0))
    });
    const poolCount = await _asyncNullishCoalesce(await _asyncOptionalChain([params, 'optionalAccess', async _4 => _4.poolCount]), async () => ( await this.getPoolCount(provider)));
    const value = this.gasConstants.claimRewardsBase + this.gasConstants.claimRewardsPerPool * BigInt(poolCount - 1);
    return { to, value, body };
  }
  async sendClaimRewards(provider, via, params) {
    const txParams = await this.getClaimRewardsTxParams(provider, params);
    return via.send(txParams);
  }
  async createUnstakeBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkJLYOJWE3cjs.FARM_OP_CODES.UNSTAKE, 32).storeUint(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _5 => _5.queryId]), () => ( 0)), 64).endCell();
  }
  /**
   * Build all data required to execute a `unstake` transaction.
   *
   * @param {number | undefined} params.poolCount -  Optional; Number of deployed farm reward pools; If undefined value will get onchain
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} all data required to execute a `unstake` transaction.
   */
  async getUnstakeTxParams(provider, params) {
    const to = this.address;
    const body = await this.createUnstakeBody({
      queryId: _optionalChain([params, 'optionalAccess', _6 => _6.queryId])
    });
    const poolCount = await _asyncNullishCoalesce(await _asyncOptionalChain([params, 'optionalAccess', async _7 => _7.poolCount]), async () => ( await this.getPoolCount(provider)));
    const value = this.gasConstants.unstakeBase + this.gasConstants.unstakePerPool * BigInt(poolCount - 1);
    return { to, value, body };
  }
  async sendUnstake(provider, via, params) {
    const txParams = await this.getUnstakeTxParams(provider, params);
    return via.send(txParams);
  }
  async createDestroyBody(params) {
    return _chunk3ATZT4MWcjs.createSbtDestroyMessage.call(void 0, {
      queryId: _nullishCoalesce(_optionalChain([params, 'optionalAccess', _8 => _8.queryId]), () => ( 0))
    });
  }
  /**
   * Build all data required to execute a `destroy` transaction.
   *
   * @param {bigint | string | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} all data required to execute a `destroy` transaction.
   */
  async getDestroyTxParams(provider, params) {
    const to = this.address;
    const body = await this.createDestroyBody({
      queryId: _optionalChain([params, 'optionalAccess', _9 => _9.queryId])
    });
    const value = this.gasConstants.destroy;
    return { to, value, body };
  }
  async sendDestroy(provider, via, params) {
    const txParams = await this.getDestroyTxParams(provider, params);
    return via.send(txParams);
  }
  /**
   * @returns structure containing current state of the farm NFT
   *
   * @property {number} status Status of the contract: uninitialized (0), active (1), unstaked (2), claiming (3), unstaked_pending (4)
   * @property {bigint} revokeTime Timestamp of unstake
   * @property {bigint} stakedTokens Amount of staked tokens
   * @property {bigint} stakeDate Timestamp in which the owner started staking
   * @property {Map<number, bigint>} claimedPerUnit `accrued_per_unit_nanorewards amounts` for each pool at the time of last claim for this user
   * @property {Address} ownerAddress Owner address of farm nft
   */
  async getFarmingData(provider) {
    const result = await provider.get("get_farming_data", []);
    return {
      status: result.stack.readNumber(),
      revokeTime: result.stack.readBigNumber(),
      stakedTokens: result.stack.readBigNumber(),
      stakeDate: result.stack.readBigNumber(),
      claimedPerUnit: (() => {
        const dict = _optionalChain([result, 'access', _10 => _10.stack, 'access', _11 => _11.readCellOpt, 'call', _12 => _12(), 'optionalAccess', _13 => _13.asSlice, 'call', _14 => _14(), 'access', _15 => _15.loadDictDirect, 'call', _16 => _16(
          _ton.Dictionary.Keys.Uint(8),
          _ton.Dictionary.Values.BigUint(150)
        )]);
        const claimedPerUnit = /* @__PURE__ */ new Map();
        if (dict) {
          for (const poolIndex of dict.keys()) {
            const accruedPerUnitNanorewards = dict.get(poolIndex);
            if (accruedPerUnitNanorewards === void 0) {
              throw new Error(
                `Failed to parse claimedPerUnit from dict: ${dict}`
              );
            }
            claimedPerUnit.set(Number(poolIndex), accruedPerUnitNanorewards);
          }
        }
        return claimedPerUnit;
      })(),
      ownerAddress: result.stack.readAddress()
    };
  }
  async getPoolCount(provider) {
    const result = await provider.get("get_nft_data", []);
    const nftItemData = {
      isInitialized: result.stack.readBoolean(),
      index: result.stack.readNumber(),
      minterAddress: result.stack.readAddress()
    };
    const { poolCount } = await provider.open(_chunkKMDPQX63cjs.FarmNftMinterV3.create(nftItemData.minterAddress)).getFarmingMinterData();
    return poolCount;
  }
}, _class.__initStatic(), _class.__initStatic2(), _class);



exports.FarmNftItemV3 = FarmNftItemV3;
//# sourceMappingURL=chunk-C2UCZSWB.cjs.map