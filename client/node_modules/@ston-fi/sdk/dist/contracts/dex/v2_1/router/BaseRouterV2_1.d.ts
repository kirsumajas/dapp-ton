import { Cell, ContractProvider, SenderArguments, Sender, Address } from '@ton/ton';
import { AddressType, AmountType, QueryIdType } from '../../../../types.js';
import { ContractOptions, Contract } from '../../../core/Contract.js';
import { AbstractPton } from '../../../pTON/AbstractPton.js';
import { DEX_VERSION, DEX_TYPE } from '../../constants.js';
import { BasePoolV2_1 } from '../pool/BasePoolV2_1.js';
import { VaultV2_1 } from '../vault/VaultV2_1.js';
import '../../../pTON/constants.js';
import '../../../core/JettonMinter.js';
import '../../../core/JettonWallet.js';
import '../LpAccount/LpAccountV2_1.js';

interface BaseRouterV2_1Options extends ContractOptions {
    gasConstants?: Partial<typeof BaseRouterV2_1.gasConstants>;
    txDeadline?: number;
}
declare class BaseRouterV2_1 extends Contract {
    static readonly version: DEX_VERSION;
    static readonly gasConstants: {
        swapJettonToJetton: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        swapJettonToTon: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        swapTonToJetton: {
            forwardGasAmount: bigint;
        };
        provideLpJetton: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        provideLpTon: {
            forwardGasAmount: bigint;
        };
        singleSideProvideLpJetton: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        singleSideProvideLpTon: {
            forwardGasAmount: bigint;
        };
    };
    readonly gasConstants: {
        swapJettonToJetton: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        swapJettonToTon: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        swapTonToJetton: {
            forwardGasAmount: bigint;
        };
        provideLpJetton: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        provideLpTon: {
            forwardGasAmount: bigint;
        };
        singleSideProvideLpJetton: {
            gasAmount: bigint;
            forwardGasAmount: bigint;
        };
        singleSideProvideLpTon: {
            forwardGasAmount: bigint;
        };
    };
    private readonly txDeadline;
    constructor(address: AddressType, { gasConstants, txDeadline, ...options }?: BaseRouterV2_1Options);
    createSwapBody(params: {
        askJettonWalletAddress: AddressType;
        receiverAddress: AddressType;
        minAskAmount: AmountType;
        refundAddress: AddressType;
        excessesAddress?: AddressType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        refundPayload?: Cell;
        refundForwardGasAmount?: AmountType;
        referralAddress?: AddressType;
        referralValue?: AmountType;
        deadline?: number;
    }): Promise<Cell>;
    createCrossSwapBody(params: {
        askJettonWalletAddress: AddressType;
        receiverAddress: AddressType;
        minAskAmount: AmountType;
        refundAddress: AddressType;
        excessesAddress?: AddressType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        refundPayload?: Cell;
        refundForwardGasAmount?: AmountType;
        referralAddress?: AddressType;
        referralValue?: AmountType;
        deadline?: number;
    }): Promise<Cell>;
    getSwapJettonToJettonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        offerJettonAddress: AddressType;
        askJettonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        referralAddress?: AddressType;
        referralValue?: AmountType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        refundPayload?: Cell;
        refundForwardGasAmount?: AmountType;
        deadline?: number;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
        jettonCustomPayload?: Cell;
        transferExcessAddress?: AddressType;
    }): Promise<SenderArguments>;
    sendSwapJettonToJetton(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getSwapJettonToJettonTxParams"]>[1]): Promise<void>;
    getSwapJettonToTonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        offerJettonAddress: AddressType;
        proxyTon: AbstractPton;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        referralAddress?: AddressType;
        referralValue?: AmountType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        refundPayload?: Cell;
        refundForwardGasAmount?: AmountType;
        deadline?: number;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
        jettonCustomPayload?: Cell;
        transferExcessAddress?: AddressType;
    }): Promise<SenderArguments>;
    sendSwapJettonToTon(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getSwapJettonToTonTxParams"]>[1]): Promise<void>;
    getSwapTonToJettonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        proxyTon: AbstractPton;
        askJettonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        referralAddress?: AddressType;
        referralValue?: AmountType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        refundPayload?: Cell;
        refundForwardGasAmount?: AmountType;
        deadline?: number;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<SenderArguments>;
    sendSwapTonToJetton(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getSwapTonToJettonTxParams"]>[1]): Promise<void>;
    createProvideLiquidityBody(params: {
        routerWalletAddress: AddressType;
        minLpOut: AmountType;
        receiverAddress: AddressType;
        refundAddress: AddressType;
        excessesAddress?: AddressType;
        bothPositive: boolean;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        deadline?: number;
    }): Promise<Cell>;
    getProvideLiquidityJettonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        sendTokenAddress: AddressType;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        deadline?: number;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
        jettonCustomPayload?: Cell;
        transferExcessAddress?: AddressType;
    }): Promise<SenderArguments>;
    sendProvideLiquidityJetton(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getProvideLiquidityJettonTxParams"]>[1]): Promise<void>;
    getSingleSideProvideLiquidityJettonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        sendTokenAddress: AddressType;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        deadline?: number;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
        jettonCustomPayload?: Cell;
        transferExcessAddress?: AddressType;
    }): Promise<SenderArguments>;
    sendSingleSideProvideLiquidityJetton(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getSingleSideProvideLiquidityJettonTxParams"]>[1]): Promise<void>;
    protected implGetProvideLiquidityJettonTxParams(provider: ContractProvider, params: Parameters<BaseRouterV2_1["getProvideLiquidityJettonTxParams"]>[1] & {
        gasAmount: AmountType;
        forwardGasAmount: AmountType;
        bothPositive: boolean;
    }): Promise<{
        to: Address;
        value: bigint;
        body: Cell;
    }>;
    getProvideLiquidityTonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        proxyTon: AbstractPton;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        bothPositive?: boolean;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        deadline?: number;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<SenderArguments>;
    sendProvideLiquidityTon(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getProvideLiquidityTonTxParams"]>[1]): Promise<void>;
    getSingleSideProvideLiquidityTonTxParams(provider: ContractProvider, params: {
        userWalletAddress: AddressType;
        receiverAddress?: AddressType;
        proxyTon: AbstractPton;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        refundAddress?: AddressType;
        excessesAddress?: AddressType;
        bothPositive?: boolean;
        dexCustomPayload?: Cell;
        dexCustomPayloadForwardGasAmount?: AmountType;
        deadline?: number;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<SenderArguments>;
    sendSingleSideProvideLiquidityTon(provider: ContractProvider, via: Sender, params: Parameters<BaseRouterV2_1["getSingleSideProvideLiquidityTonTxParams"]>[1]): Promise<void>;
    protected implGetProvideLiquidityTonTxParams(provider: ContractProvider, params: Parameters<BaseRouterV2_1["getProvideLiquidityTonTxParams"]>[1] & {
        forwardGasAmount: AmountType;
        bothPositive: boolean;
    }): Promise<SenderArguments>;
    private maybeReferralAddress;
    private get defaultDeadline();
    private assertProxyTon;
    getPoolAddress(provider: ContractProvider, params: {
        token0: AddressType;
        token1: AddressType;
    }): Promise<Address>;
    getPoolAddressByJettonMinters(provider: ContractProvider, params: {
        token0: AddressType;
        token1: AddressType;
    }): Promise<Address>;
    getPool(provider: ContractProvider, params: {
        token0: AddressType;
        token1: AddressType;
    }): Promise<BasePoolV2_1>;
    getVaultAddress(provider: ContractProvider, params: {
        user: AddressType;
        tokenWallet: AddressType;
    }): Promise<Address>;
    getVault(provider: ContractProvider, params: {
        user: AddressType;
        tokenMinter: AddressType;
    }): Promise<VaultV2_1>;
    getRouterVersion(provider: ContractProvider): Promise<{
        major: number;
        minor: number;
        development: string;
    }>;
    getRouterData(provider: ContractProvider): Promise<{
        routerId: number;
        dexType: DEX_TYPE;
        isLocked: boolean;
        adminAddress: Address;
        tempUpgrade: Cell;
        poolCode: Cell;
        jettonLpWalletCode: Cell;
        lpAccountCode: Cell;
        vaultCode: Cell;
    }>;
}

export { BaseRouterV2_1, type BaseRouterV2_1Options };
