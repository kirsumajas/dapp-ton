{"version":3,"sources":["/Users/paul-n/git/ston-fi/public/sdk-contracts/packages/sdk/dist/chunk-KMDPQX63.cjs","../src/contracts/farm/v3/FarmNftMinterV3.ts"],"names":[],"mappings":"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","file":"/Users/paul-n/git/ston-fi/public/sdk-contracts/packages/sdk/dist/chunk-KMDPQX63.cjs","sourcesContent":[null,"import {\n  type Address,\n  type Cell,\n  type ContractProvider,\n  Dictionary,\n  type Sender,\n  type SenderArguments,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { createJettonTransferMessage } from \"../../../utils/createJettonTransferMessage\";\nimport { toAddress } from \"../../../utils/toAddress\";\nimport { Contract, type ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { JettonWallet } from \"../../core/JettonWallet\";\nimport { FARM_OP_CODES, FARM_VERSION } from \"../constants\";\n\n/**\n *  @type {FarmDataAccrued} represent state of the accrued data for pool\n *\n * @property {bigint} depositedNanorewards - Deposited rewards in nanounits\n * @property {bigint} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n * @property {bigint} accruedFeeNanorewards - Accrued fees\n * @property {bigint} claimedNanorewards - Number of claimed rewards in nanounits\n * @property {bigint} claimedFeeNanorewards - Claimed fees\n * @property {bigint} accruedNanorewards - Total number of accrued rewards in nanounits\n * @property {bigint} lastUpdateTime - Last time farming values were updated\n */\nexport type FarmDataAccrued = {\n  depositedNanorewards: bigint;\n  accruedPerUnitNanorewards: bigint;\n  accruedFeeNanorewards: bigint;\n  claimedNanorewards: bigint;\n  claimedFeeNanorewards: bigint;\n  accruedNanorewards: bigint;\n  lastUpdateTime: bigint;\n};\n\n/**\n *  @type {FarmDataParameters} represent state of the pool parameters\n *\n * @property {bigint} adminFee - Admin fee; divider is 10000\n * @property {bigint} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n * @property {boolean} unrestrictedDepositRewards - If rewards can be deposited by anyone\n * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n * @property {boolean} canChangeFee - If can change fee\n * @property {number} status - Status of the contract\n * @property {number} rampDays - Days of ramp, affect deposit rewards @since v3.2\n */\nexport type FarmDataParameters = {\n  adminFee: bigint;\n  nanorewardsPer24h: bigint;\n  unrestrictedDepositRewards: boolean;\n  rewardTokenWallet: Address;\n  canChangeFee: boolean;\n  status: number;\n  rampDays: number | null;\n};\n\nexport interface FarmNftMinterV3Options extends ContractOptions {\n  gasConstants?: Partial<typeof FarmNftMinterV3.gasConstants>;\n}\n\nexport class FarmNftMinterV3 extends Contract {\n  public static readonly version: FARM_VERSION = FARM_VERSION.v3;\n\n  public static readonly gasConstants = {\n    stakeFwdBase: toNano(\"0.21\"),\n    stakeFwdPerPool: toNano(\"0.015\"),\n    stake: toNano(\"0.1\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: FarmNftMinterV3Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...FarmNftMinterV3.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createStakeBody(params?: {\n    ownerAddress?: AddressType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(FARM_OP_CODES.STAKE, 32)\n      .storeAddress(\n        params?.ownerAddress ? toAddress(params.ownerAddress) : undefined,\n      )\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {bigint | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain\n   * @param {Address | string} params.ownerAddress - Optional; custom owner of stake; if undefined stake owner is sender address\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} containing all data required to execute a jetton `stake` transaction\n   */\n  public async getStakeTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      jettonAddress: AddressType;\n      jettonAmount: AmountType;\n      poolCount?: number;\n      ownerAddress?: AddressType;\n      queryId?: QueryIdType;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, forwardPayload, poolCount] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.jettonAddress))\n        .getWalletAddress(params.userWalletAddress),\n      this.createStakeBody({\n        ownerAddress: params.ownerAddress,\n      }),\n      (async () =>\n        params.poolCount ??\n        (await this.getFarmingMinterData(provider)).poolCount)(),\n    ]);\n\n    const forwardTonAmount =\n      this.gasConstants.stakeFwdBase +\n      this.gasConstants.stakeFwdPerPool * BigInt(poolCount + 1);\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = forwardTonAmount + this.gasConstants.stake;\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendStake(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftMinterV3[\"getStakeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getStakeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton that is used for farming\n   */\n  public async getStakingJettonAddress(\n    provider: ContractProvider,\n  ): Promise<Address> {\n    const { stakingTokenWallet: stakingTokenWalletAddress } =\n      await this.getFarmingMinterData(provider);\n\n    const { jettonMasterAddress } = await provider\n      .open(JettonWallet.create(stakingTokenWalletAddress))\n      .getWalletData();\n\n    return jettonMasterAddress;\n  }\n\n  /**\n   * @returns structure containing pending data\n   *\n   * @property {bigint} changeCustodianTs - Timestamp when 'change_custodian' was initiated\n   * @property {bigint} sendMsgTs - Timestamp when 'send_raw_msg' was initiated\n   * @property {bigint} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated\n   * @property {Address} newCustodian - New custodian that will be set after confirmation\n   * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation\n   * @property {Cell} newCode - New contract code that will be set after confirmation\n   * @property {Cell} newStorage - New contract storage that will be set after confirmation\n   */\n  public async getPendingData(provider: ContractProvider) {\n    const result = await provider.get(\"get_pending_data\", []);\n\n    return {\n      changeCustodianTs: result.stack.readBigNumber(),\n      sendMsgTs: result.stack.readBigNumber(),\n      codeUpgradeTs: result.stack.readBigNumber(),\n      newCustodian: result.stack.readAddressOpt(),\n      pendingMsg: result.stack.readCell(),\n      newCode: result.stack.readCell(),\n      newStorage: result.stack.readCell(),\n    };\n  }\n\n  /**\n   * @returns structure containing version data\n   *\n   * @property {number} major - Major version; breaking changes in api\n   * @property {number} minor - Minor version; non-breaking new functionality\n   * @property {string} development - Development version; can contain breaking changes\n   */\n  public async getVersion(provider: ContractProvider) {\n    const result = await provider.get(\"get_version\", []);\n\n    return {\n      major: result.stack.readNumber(),\n      minor: result.stack.readNumber(),\n      development: result.stack.readString(),\n    };\n  }\n\n  /**\n   * @returns structure containing current state of the minter\n   *\n   * @property {bigint} nextItemIndex - Index of the next nft in this collection\n   * @property {number} status - Status of the contract: uninitialized `0`, operational `1`, pause_all `2`, frozen `3`, retired `4`,\n   * @property {number} poolCount - Pools count\n   * @property {bigint} currentStakedTokens - Number of staked tokens in basic token units\n   * @property {bigint} contractUniqueId - Minter id\n   * @property {bigint} minStakeTime - Minimum staking time\n   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n   * @property {Address} custodianAddress - Custodian address\n   * @property {boolean} canChangeCustodian - If can change custodian\n   * @property {boolean} canSendRawMsg - If admin can send arbitrary raw msg from Minter\n   * @property {Map<number, FarmDataAccrued>} farmDataAccrued - Accrued data for pools\n   * @property {Map<number, FarmDataParameters>} farmDataParameters - Pools parameters\n   */\n  public async getFarmingMinterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_farming_minter_data\", []);\n    const version = await this.getVersion(provider);\n\n    return {\n      nextItemIndex: result.stack.readBigNumber(),\n      status: result.stack.readNumber(),\n      poolCount: result.stack.readNumber(),\n      currentStakedTokens: result.stack.readBigNumber(),\n      contractUniqueId: result.stack.readBigNumber(),\n      minStakeTime: result.stack.readBigNumber(),\n      stakingTokenWallet: result.stack.readAddress(),\n      custodianAddress: result.stack.readAddress(),\n      canChangeCustodian: result.stack.readBoolean(),\n      canSendRawMsg: result.stack.readBoolean(),\n      farmDataAccrued: (() => {\n        const dict = result.stack\n          .readCellOpt()\n          ?.asSlice()\n          .loadDictDirect(Dictionary.Keys.Uint(8), Dictionary.Values.Cell());\n\n        const farmDataAccrued = new Map<number, FarmDataAccrued>();\n\n        if (dict) {\n          for (const poolIndex of dict.keys()) {\n            const cell = dict.get(poolIndex);\n\n            if (cell === undefined) {\n              throw new Error(\n                `Failed to parse farmDataAccrued from dict: ${dict}`,\n              );\n            }\n\n            const slice = cell.beginParse();\n\n            const accruedData = {\n              depositedNanorewards: slice.loadUintBig(150),\n              accruedPerUnitNanorewards: slice.loadUintBig(150),\n              accruedFeeNanorewards: slice.loadUintBig(150),\n              claimedNanorewards: slice.loadUintBig(150),\n              claimedFeeNanorewards: slice.loadUintBig(150),\n              accruedNanorewards: slice.loadUintBig(150),\n              lastUpdateTime: slice.loadUintBig(64),\n            };\n\n            farmDataAccrued.set(poolIndex, accruedData);\n          }\n        }\n\n        return farmDataAccrued;\n      })(),\n      farmDataParameters: (() => {\n        const dict = result.stack\n          .readCellOpt()\n          ?.asSlice()\n          .loadDictDirect(Dictionary.Keys.Uint(8), Dictionary.Values.Cell());\n\n        const farmDataParameters = new Map<number, FarmDataParameters>();\n\n        if (dict) {\n          for (const poolIndex of dict.keys()) {\n            const cell = dict.get(poolIndex);\n\n            if (cell === undefined) {\n              throw new Error(\n                `Failed to parse farmDataParameters from dict: ${dict}`,\n              );\n            }\n\n            const slice = cell.beginParse();\n\n            const parametersData = {\n              adminFee: slice.loadUintBig(16),\n              nanorewardsPer24h: slice.loadUintBig(150),\n              unrestrictedDepositRewards: slice.loadBit(),\n              rewardTokenWallet: slice.loadAddress(),\n              canChangeFee: slice.loadBit(),\n              status: slice.loadUint(8),\n              rampDays:\n                version.major === 3 && version.minor === 2\n                  ? slice.loadUint(16)\n                  : null,\n            };\n            farmDataParameters.set(poolIndex, parametersData);\n          }\n        }\n\n        return farmDataParameters;\n      })(),\n    };\n  }\n}\n"]}