{"version":3,"sources":["/Users/paul-n/git/ston-fi/public/sdk-contracts/packages/sdk/dist/chunk-V4QW6ZFU.cjs","../src/contracts/dex/v1/RouterV1.ts"],"names":["address"],"mappings":"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","file":"/Users/paul-n/git/ston-fi/public/sdk-contracts/packages/sdk/dist/chunk-V4QW6ZFU.cjs","sourcesContent":[null,"import {\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  address,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { createJettonTransferMessage } from \"../../../utils/createJettonTransferMessage\";\nimport { toAddress } from \"../../../utils/toAddress\";\nimport { Contract, type ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { HOLE_ADDRESS } from \"../../core/constants\";\nimport { pTON_VERSION } from \"../../pTON\";\nimport type { AbstractPton } from \"../../pTON/AbstractPton\";\nimport { DEX_VERSION } from \"../constants\";\nimport * as Errors from \"../errors\";\nimport { PoolV1 } from \"./PoolV1\";\nimport { DEX_OP_CODES, ROUTER_ADDRESS } from \"./constants\";\n\nexport interface RouterV1Options extends ContractOptions {\n  gasConstants?: Partial<typeof RouterV1.gasConstants>;\n}\n\n/**\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class RouterV1 extends Contract {\n  public static readonly version: DEX_VERSION = DEX_VERSION.v1;\n  public static readonly address = address(ROUTER_ADDRESS);\n  public static readonly gasConstants = {\n    swapJettonToJetton: {\n      gasAmount: toNano(\"0.22\"),\n      forwardGasAmount: toNano(\"0.175\"),\n    },\n    swapJettonToTon: {\n      gasAmount: toNano(\"0.17\"),\n      forwardGasAmount: toNano(\"0.125\"),\n    },\n    swapTonToJetton: {\n      forwardGasAmount: toNano(\"0.185\"),\n    },\n    provideLpJetton: {\n      gasAmount: toNano(\"0.3\"),\n      forwardGasAmount: toNano(\"0.24\"),\n    },\n    provideLpTon: {\n      forwardGasAmount: toNano(\"0.26\"),\n    },\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType = RouterV1.address,\n    { gasConstants, ...options }: RouterV1Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...RouterV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    const builder = beginCell();\n\n    builder.storeUint(DEX_OP_CODES.SWAP, 32);\n    builder.storeAddress(toAddress(params.askJettonWalletAddress));\n    builder.storeCoins(BigInt(params.minAskAmount));\n    builder.storeAddress(toAddress(params.userWalletAddress));\n\n    const referralAddress = this.maybeReferralAddress(params.referralAddress);\n\n    if (referralAddress) {\n      builder.storeUint(1, 1);\n      builder.storeAddress(referralAddress);\n    } else {\n      builder.storeUint(0, 1);\n    }\n\n    return builder.endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} data required to execute a jetton `swap` transaction\n   */\n  public async getSwapJettonToJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      offerJettonAddress: AddressType;\n      askJettonAddress: AddressType;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      jettonCustomPayload?: Cell;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [offerJettonWalletAddress, askJettonWalletAddress] =\n      await Promise.all([\n        provider\n          .open(JettonMinter.create(params.offerJettonAddress))\n          .getWalletAddress(params.userWalletAddress),\n        provider\n          .open(JettonMinter.create(params.askJettonAddress))\n          .getWalletAddress(this.address),\n      ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.swapJettonToJetton.forwardGasAmount,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      customPayload: params.jettonCustomPayload,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(\n      params.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount,\n    );\n\n    return {\n      to: offerJettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendSwapJettonToJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapJettonToJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapJettonToJettonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Build all data required to execute a jetton to ton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {PtonV1} params.proxyTon - Proxy ton contract\n   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} data required to execute a jetton `swap` transaction\n   */\n  public async getSwapJettonToTonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      offerJettonAddress: AddressType;\n      proxyTon: AbstractPton;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      jettonCustomPayload?: Cell;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    this.assertProxyTon(params.proxyTon);\n\n    return await this.getSwapJettonToJettonTxParams(provider, {\n      ...params,\n      askJettonAddress: params.proxyTon.address,\n      gasAmount:\n        params.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,\n      forwardGasAmount:\n        params.forwardGasAmount ??\n        this.gasConstants.swapJettonToTon.forwardGasAmount,\n    });\n  }\n\n  public async sendSwapJettonToTon(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapJettonToTonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapJettonToTonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {PtonV1} params.proxyTon - Proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {bigint | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a ton to jetton `swap` transaction\n   */\n  public async getSwapTonToJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      proxyTon: AbstractPton;\n      askJettonAddress: AddressType;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType | undefined;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    this.assertProxyTon(params.proxyTon);\n\n    const askJettonWalletAddress = await provider\n      .open(JettonMinter.create(params.askJettonAddress))\n      .getWalletAddress(this.address);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.swapTonToJetton.forwardGasAmount,\n    );\n\n    return await provider.open(params.proxyTon).getTonTransferTxParams({\n      queryId: params.queryId ?? 0,\n      tonAmount: params.offerAmount,\n      destinationAddress: this.address,\n      refundAddress: params.userWalletAddress,\n      forwardPayload,\n      forwardTonAmount,\n    });\n  }\n\n  public async sendSwapTonToJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapTonToJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapTonToJettonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.PROVIDE_LP, 32)\n      .storeAddress(toAddress(params.routerWalletAddress))\n      .storeCoins(BigInt(params.minLpOut))\n      .endCell();\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {bigint | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message\n   *\n   * @returns {SenderArguments} data required to execute a jetton `provide_lp` transaction\n   */\n  public async getProvideLiquidityJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      sendTokenAddress: AddressType;\n      otherTokenAddress: AddressType;\n      sendAmount: AmountType;\n      minLpOut: AmountType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      jettonCustomPayload?: Cell;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.sendTokenAddress))\n        .getWalletAddress(params.userWalletAddress),\n      provider\n        .open(JettonMinter.create(params.otherTokenAddress))\n        .getWalletAddress(this.address),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpJetton.forwardGasAmount,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      customPayload: params.jettonCustomPayload,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(\n      params.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount,\n    );\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendProvideLiquidityJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getProvideLiquidityJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getProvideLiquidityJettonTxParams(\n      provider,\n      params,\n    );\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {PtonV1} params.proxyTon - proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {bigint | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async getProvideLiquidityTonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      proxyTon: AbstractPton;\n      otherTokenAddress: AddressType;\n      sendAmount: AmountType;\n      minLpOut: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    this.assertProxyTon(params.proxyTon);\n\n    const routerWalletAddress = await provider\n      .open(JettonMinter.create(params.otherTokenAddress))\n      .getWalletAddress(this.address);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpTon.forwardGasAmount,\n    );\n\n    return await provider.open(params.proxyTon).getTonTransferTxParams({\n      queryId: params.queryId ?? 0,\n      tonAmount: params.sendAmount,\n      destinationAddress: this.address,\n      refundAddress: params.userWalletAddress,\n      forwardPayload,\n      forwardTonAmount,\n    });\n  }\n\n  public async sendProvideLiquidityTon(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getProvideLiquidityTonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getProvideLiquidityTonTxParams(\n      provider,\n      params,\n    );\n\n    return via.send(txParams);\n  }\n\n  private assertProxyTon(proxyTon: AbstractPton) {\n    if (proxyTon.version !== pTON_VERSION.v1) {\n      throw new Errors.UnmatchedPtonVersion({\n        expected: pTON_VERSION.v1,\n        received: proxyTon.version,\n      });\n    }\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   *\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_pool_address\", [\n      {\n        type: \"slice\",\n        cell: beginCell().storeAddress(toAddress(params.token0)).endCell(),\n      },\n      {\n        type: \"slice\",\n        cell: beginCell().storeAddress(toAddress(params.token1)).endCell(),\n      },\n    ]);\n\n    return result.stack.readAddress();\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {Address} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddressByJettonMinters(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.token0))\n        .getWalletAddress(this.address),\n      provider\n        .open(JettonMinter.create(params.token1))\n        .getWalletAddress(this.address),\n    ]);\n\n    const poolAddress = await this.getPoolAddress(provider, {\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    return poolAddress;\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {PoolV1} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const poolAddress = await this.getPoolAddressByJettonMinters(provider, {\n      token0: params.token0,\n      token1: params.token1,\n    });\n\n    return PoolV1.create(poolAddress);\n  }\n\n  /**\n   * @returns current state of the router.\n   */\n  public async getRouterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_router_data\", []);\n\n    return {\n      isLocked: result.stack.readBoolean(),\n      adminAddress: result.stack.readAddress(),\n      tempUpgrade: result.stack.readCell(),\n      poolCode: result.stack.readCell(),\n      jettonLpWalletCode: result.stack.readCell(),\n      lpAccountCode: result.stack.readCell(),\n    };\n  }\n\n  private maybeReferralAddress(referralAddress: AddressType | undefined) {\n    if (!referralAddress) return null;\n\n    const referralAddressParsed = toAddress(referralAddress);\n\n    // ignore hole address as referral address\n    if (referralAddressParsed.equals(HOLE_ADDRESS)) return null;\n\n    return referralAddressParsed;\n  }\n}\n"]}