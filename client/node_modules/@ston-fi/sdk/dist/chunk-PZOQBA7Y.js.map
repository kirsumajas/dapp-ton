{"version":3,"sources":["../src/contracts/farm/v3/FarmNftMinterV3.ts"],"sourcesContent":["import {\n  type Address,\n  type Cell,\n  type ContractProvider,\n  Dictionary,\n  type Sender,\n  type SenderArguments,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { createJettonTransferMessage } from \"../../../utils/createJettonTransferMessage\";\nimport { toAddress } from \"../../../utils/toAddress\";\nimport { Contract, type ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { JettonWallet } from \"../../core/JettonWallet\";\nimport { FARM_OP_CODES, FARM_VERSION } from \"../constants\";\n\n/**\n *  @type {FarmDataAccrued} represent state of the accrued data for pool\n *\n * @property {bigint} depositedNanorewards - Deposited rewards in nanounits\n * @property {bigint} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n * @property {bigint} accruedFeeNanorewards - Accrued fees\n * @property {bigint} claimedNanorewards - Number of claimed rewards in nanounits\n * @property {bigint} claimedFeeNanorewards - Claimed fees\n * @property {bigint} accruedNanorewards - Total number of accrued rewards in nanounits\n * @property {bigint} lastUpdateTime - Last time farming values were updated\n */\nexport type FarmDataAccrued = {\n  depositedNanorewards: bigint;\n  accruedPerUnitNanorewards: bigint;\n  accruedFeeNanorewards: bigint;\n  claimedNanorewards: bigint;\n  claimedFeeNanorewards: bigint;\n  accruedNanorewards: bigint;\n  lastUpdateTime: bigint;\n};\n\n/**\n *  @type {FarmDataParameters} represent state of the pool parameters\n *\n * @property {bigint} adminFee - Admin fee; divider is 10000\n * @property {bigint} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n * @property {boolean} unrestrictedDepositRewards - If rewards can be deposited by anyone\n * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n * @property {boolean} canChangeFee - If can change fee\n * @property {number} status - Status of the contract\n * @property {number} rampDays - Days of ramp, affect deposit rewards @since v3.2\n */\nexport type FarmDataParameters = {\n  adminFee: bigint;\n  nanorewardsPer24h: bigint;\n  unrestrictedDepositRewards: boolean;\n  rewardTokenWallet: Address;\n  canChangeFee: boolean;\n  status: number;\n  rampDays: number | null;\n};\n\nexport interface FarmNftMinterV3Options extends ContractOptions {\n  gasConstants?: Partial<typeof FarmNftMinterV3.gasConstants>;\n}\n\nexport class FarmNftMinterV3 extends Contract {\n  public static readonly version: FARM_VERSION = FARM_VERSION.v3;\n\n  public static readonly gasConstants = {\n    stakeFwdBase: toNano(\"0.21\"),\n    stakeFwdPerPool: toNano(\"0.015\"),\n    stake: toNano(\"0.1\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: FarmNftMinterV3Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...FarmNftMinterV3.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createStakeBody(params?: {\n    ownerAddress?: AddressType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(FARM_OP_CODES.STAKE, 32)\n      .storeAddress(\n        params?.ownerAddress ? toAddress(params.ownerAddress) : undefined,\n      )\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {bigint | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain\n   * @param {Address | string} params.ownerAddress - Optional; custom owner of stake; if undefined stake owner is sender address\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} containing all data required to execute a jetton `stake` transaction\n   */\n  public async getStakeTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      jettonAddress: AddressType;\n      jettonAmount: AmountType;\n      poolCount?: number;\n      ownerAddress?: AddressType;\n      queryId?: QueryIdType;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, forwardPayload, poolCount] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.jettonAddress))\n        .getWalletAddress(params.userWalletAddress),\n      this.createStakeBody({\n        ownerAddress: params.ownerAddress,\n      }),\n      (async () =>\n        params.poolCount ??\n        (await this.getFarmingMinterData(provider)).poolCount)(),\n    ]);\n\n    const forwardTonAmount =\n      this.gasConstants.stakeFwdBase +\n      this.gasConstants.stakeFwdPerPool * BigInt(poolCount + 1);\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = forwardTonAmount + this.gasConstants.stake;\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendStake(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftMinterV3[\"getStakeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getStakeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton that is used for farming\n   */\n  public async getStakingJettonAddress(\n    provider: ContractProvider,\n  ): Promise<Address> {\n    const { stakingTokenWallet: stakingTokenWalletAddress } =\n      await this.getFarmingMinterData(provider);\n\n    const { jettonMasterAddress } = await provider\n      .open(JettonWallet.create(stakingTokenWalletAddress))\n      .getWalletData();\n\n    return jettonMasterAddress;\n  }\n\n  /**\n   * @returns structure containing pending data\n   *\n   * @property {bigint} changeCustodianTs - Timestamp when 'change_custodian' was initiated\n   * @property {bigint} sendMsgTs - Timestamp when 'send_raw_msg' was initiated\n   * @property {bigint} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated\n   * @property {Address} newCustodian - New custodian that will be set after confirmation\n   * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation\n   * @property {Cell} newCode - New contract code that will be set after confirmation\n   * @property {Cell} newStorage - New contract storage that will be set after confirmation\n   */\n  public async getPendingData(provider: ContractProvider) {\n    const result = await provider.get(\"get_pending_data\", []);\n\n    return {\n      changeCustodianTs: result.stack.readBigNumber(),\n      sendMsgTs: result.stack.readBigNumber(),\n      codeUpgradeTs: result.stack.readBigNumber(),\n      newCustodian: result.stack.readAddressOpt(),\n      pendingMsg: result.stack.readCell(),\n      newCode: result.stack.readCell(),\n      newStorage: result.stack.readCell(),\n    };\n  }\n\n  /**\n   * @returns structure containing version data\n   *\n   * @property {number} major - Major version; breaking changes in api\n   * @property {number} minor - Minor version; non-breaking new functionality\n   * @property {string} development - Development version; can contain breaking changes\n   */\n  public async getVersion(provider: ContractProvider) {\n    const result = await provider.get(\"get_version\", []);\n\n    return {\n      major: result.stack.readNumber(),\n      minor: result.stack.readNumber(),\n      development: result.stack.readString(),\n    };\n  }\n\n  /**\n   * @returns structure containing current state of the minter\n   *\n   * @property {bigint} nextItemIndex - Index of the next nft in this collection\n   * @property {number} status - Status of the contract: uninitialized `0`, operational `1`, pause_all `2`, frozen `3`, retired `4`,\n   * @property {number} poolCount - Pools count\n   * @property {bigint} currentStakedTokens - Number of staked tokens in basic token units\n   * @property {bigint} contractUniqueId - Minter id\n   * @property {bigint} minStakeTime - Minimum staking time\n   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n   * @property {Address} custodianAddress - Custodian address\n   * @property {boolean} canChangeCustodian - If can change custodian\n   * @property {boolean} canSendRawMsg - If admin can send arbitrary raw msg from Minter\n   * @property {Map<number, FarmDataAccrued>} farmDataAccrued - Accrued data for pools\n   * @property {Map<number, FarmDataParameters>} farmDataParameters - Pools parameters\n   */\n  public async getFarmingMinterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_farming_minter_data\", []);\n    const version = await this.getVersion(provider);\n\n    return {\n      nextItemIndex: result.stack.readBigNumber(),\n      status: result.stack.readNumber(),\n      poolCount: result.stack.readNumber(),\n      currentStakedTokens: result.stack.readBigNumber(),\n      contractUniqueId: result.stack.readBigNumber(),\n      minStakeTime: result.stack.readBigNumber(),\n      stakingTokenWallet: result.stack.readAddress(),\n      custodianAddress: result.stack.readAddress(),\n      canChangeCustodian: result.stack.readBoolean(),\n      canSendRawMsg: result.stack.readBoolean(),\n      farmDataAccrued: (() => {\n        const dict = result.stack\n          .readCellOpt()\n          ?.asSlice()\n          .loadDictDirect(Dictionary.Keys.Uint(8), Dictionary.Values.Cell());\n\n        const farmDataAccrued = new Map<number, FarmDataAccrued>();\n\n        if (dict) {\n          for (const poolIndex of dict.keys()) {\n            const cell = dict.get(poolIndex);\n\n            if (cell === undefined) {\n              throw new Error(\n                `Failed to parse farmDataAccrued from dict: ${dict}`,\n              );\n            }\n\n            const slice = cell.beginParse();\n\n            const accruedData = {\n              depositedNanorewards: slice.loadUintBig(150),\n              accruedPerUnitNanorewards: slice.loadUintBig(150),\n              accruedFeeNanorewards: slice.loadUintBig(150),\n              claimedNanorewards: slice.loadUintBig(150),\n              claimedFeeNanorewards: slice.loadUintBig(150),\n              accruedNanorewards: slice.loadUintBig(150),\n              lastUpdateTime: slice.loadUintBig(64),\n            };\n\n            farmDataAccrued.set(poolIndex, accruedData);\n          }\n        }\n\n        return farmDataAccrued;\n      })(),\n      farmDataParameters: (() => {\n        const dict = result.stack\n          .readCellOpt()\n          ?.asSlice()\n          .loadDictDirect(Dictionary.Keys.Uint(8), Dictionary.Values.Cell());\n\n        const farmDataParameters = new Map<number, FarmDataParameters>();\n\n        if (dict) {\n          for (const poolIndex of dict.keys()) {\n            const cell = dict.get(poolIndex);\n\n            if (cell === undefined) {\n              throw new Error(\n                `Failed to parse farmDataParameters from dict: ${dict}`,\n              );\n            }\n\n            const slice = cell.beginParse();\n\n            const parametersData = {\n              adminFee: slice.loadUintBig(16),\n              nanorewardsPer24h: slice.loadUintBig(150),\n              unrestrictedDepositRewards: slice.loadBit(),\n              rewardTokenWallet: slice.loadAddress(),\n              canChangeFee: slice.loadBit(),\n              status: slice.loadUint(8),\n              rampDays:\n                version.major === 3 && version.minor === 2\n                  ? slice.loadUint(16)\n                  : null,\n            };\n            farmDataParameters.set(poolIndex, parametersData);\n          }\n        }\n\n        return farmDataParameters;\n      })(),\n    };\n  }\n}\n"],"mappings":"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","names":[]}