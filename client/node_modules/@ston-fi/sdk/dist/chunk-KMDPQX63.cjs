"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } async function _asyncNullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return await rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;


var _chunkJLYOJWE3cjs = require('./chunk-JLYOJWE3.cjs');


var _chunkWF6EZ2CWcjs = require('./chunk-WF6EZ2CW.cjs');


var _chunkVJSHCTQ7cjs = require('./chunk-VJSHCTQ7.cjs');


var _chunkIIMQROIVcjs = require('./chunk-IIMQROIV.cjs');


var _chunkKBINKP7Dcjs = require('./chunk-KBINKP7D.cjs');


var _chunkQBYZPWDOcjs = require('./chunk-QBYZPWDO.cjs');

// src/contracts/farm/v3/FarmNftMinterV3.ts




var _ton = require('@ton/ton');
var FarmNftMinterV3 = (_class = class _FarmNftMinterV3 extends _chunkIIMQROIVcjs.Contract {
  static __initStatic() {this.version = _chunkJLYOJWE3cjs.FARM_VERSION.v3}
  static __initStatic2() {this.gasConstants = {
    stakeFwdBase: _ton.toNano.call(void 0, "0.21"),
    stakeFwdPerPool: _ton.toNano.call(void 0, "0.015"),
    stake: _ton.toNano.call(void 0, "0.1")
  }}
  
  constructor(address, { gasConstants, ...options } = {}) {
    super(address, options);
    this.gasConstants = {
      ..._FarmNftMinterV3.gasConstants,
      ...gasConstants
    };
  }
  async createStakeBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkJLYOJWE3cjs.FARM_OP_CODES.STAKE, 32).storeAddress(
      _optionalChain([params, 'optionalAccess', _ => _.ownerAddress]) ? _chunkQBYZPWDOcjs.toAddress.call(void 0, params.ownerAddress) : void 0
    ).endCell();
  }
  /**
   * Build all data required to execute a jetton `stake` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
   * @param {bigint | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
   * @param {number | undefined} params.poolCount - Optional; Number of deployed farm reward pools; If undefined value will get onchain
   * @param {Address | string} params.ownerAddress - Optional; custom owner of stake; if undefined stake owner is sender address
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens
   *
   * @returns {SenderArguments} containing all data required to execute a jetton `stake` transaction
   */
  async getStakeTxParams(provider, params) {
    const [jettonWalletAddress, forwardPayload, poolCount] = await Promise.all([
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.jettonAddress)).getWalletAddress(params.userWalletAddress),
      this.createStakeBody({
        ownerAddress: params.ownerAddress
      }),
      (async () => await _asyncNullishCoalesce(params.poolCount, async () => ( (await this.getFarmingMinterData(provider)).poolCount)))()
    ]);
    const forwardTonAmount = this.gasConstants.stakeFwdBase + this.gasConstants.stakeFwdPerPool * BigInt(poolCount + 1);
    const body = _chunkKBINKP7Dcjs.createJettonTransferMessage.call(void 0, {
      queryId: _nullishCoalesce(params.queryId, () => ( 0)),
      amount: params.jettonAmount,
      destination: this.address,
      responseDestination: _nullishCoalesce(params.transferExcessAddress, () => ( params.userWalletAddress)),
      forwardTonAmount,
      forwardPayload
    });
    const value = forwardTonAmount + this.gasConstants.stake;
    return {
      to: jettonWalletAddress,
      value,
      body
    };
  }
  async sendStake(provider, via, params) {
    const txParams = await this.getStakeTxParams(provider, params);
    return via.send(txParams);
  }
  /**
   * @returns {Address} address of minter for staking jetton that is used for farming
   */
  async getStakingJettonAddress(provider) {
    const { stakingTokenWallet: stakingTokenWalletAddress } = await this.getFarmingMinterData(provider);
    const { jettonMasterAddress } = await provider.open(_chunkVJSHCTQ7cjs.JettonWallet.create(stakingTokenWalletAddress)).getWalletData();
    return jettonMasterAddress;
  }
  /**
   * @returns structure containing pending data
   *
   * @property {bigint} changeCustodianTs - Timestamp when 'change_custodian' was initiated
   * @property {bigint} sendMsgTs - Timestamp when 'send_raw_msg' was initiated
   * @property {bigint} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated
   * @property {Address} newCustodian - New custodian that will be set after confirmation
   * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation
   * @property {Cell} newCode - New contract code that will be set after confirmation
   * @property {Cell} newStorage - New contract storage that will be set after confirmation
   */
  async getPendingData(provider) {
    const result = await provider.get("get_pending_data", []);
    return {
      changeCustodianTs: result.stack.readBigNumber(),
      sendMsgTs: result.stack.readBigNumber(),
      codeUpgradeTs: result.stack.readBigNumber(),
      newCustodian: result.stack.readAddressOpt(),
      pendingMsg: result.stack.readCell(),
      newCode: result.stack.readCell(),
      newStorage: result.stack.readCell()
    };
  }
  /**
   * @returns structure containing version data
   *
   * @property {number} major - Major version; breaking changes in api
   * @property {number} minor - Minor version; non-breaking new functionality
   * @property {string} development - Development version; can contain breaking changes
   */
  async getVersion(provider) {
    const result = await provider.get("get_version", []);
    return {
      major: result.stack.readNumber(),
      minor: result.stack.readNumber(),
      development: result.stack.readString()
    };
  }
  /**
   * @returns structure containing current state of the minter
   *
   * @property {bigint} nextItemIndex - Index of the next nft in this collection
   * @property {number} status - Status of the contract: uninitialized `0`, operational `1`, pause_all `2`, frozen `3`, retired `4`,
   * @property {number} poolCount - Pools count
   * @property {bigint} currentStakedTokens - Number of staked tokens in basic token units
   * @property {bigint} contractUniqueId - Minter id
   * @property {bigint} minStakeTime - Minimum staking time
   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet
   * @property {Address} custodianAddress - Custodian address
   * @property {boolean} canChangeCustodian - If can change custodian
   * @property {boolean} canSendRawMsg - If admin can send arbitrary raw msg from Minter
   * @property {Map<number, FarmDataAccrued>} farmDataAccrued - Accrued data for pools
   * @property {Map<number, FarmDataParameters>} farmDataParameters - Pools parameters
   */
  async getFarmingMinterData(provider) {
    const result = await provider.get("get_farming_minter_data", []);
    const version = await this.getVersion(provider);
    return {
      nextItemIndex: result.stack.readBigNumber(),
      status: result.stack.readNumber(),
      poolCount: result.stack.readNumber(),
      currentStakedTokens: result.stack.readBigNumber(),
      contractUniqueId: result.stack.readBigNumber(),
      minStakeTime: result.stack.readBigNumber(),
      stakingTokenWallet: result.stack.readAddress(),
      custodianAddress: result.stack.readAddress(),
      canChangeCustodian: result.stack.readBoolean(),
      canSendRawMsg: result.stack.readBoolean(),
      farmDataAccrued: (() => {
        const dict = _optionalChain([result, 'access', _2 => _2.stack, 'access', _3 => _3.readCellOpt, 'call', _4 => _4(), 'optionalAccess', _5 => _5.asSlice, 'call', _6 => _6(), 'access', _7 => _7.loadDictDirect, 'call', _8 => _8(_ton.Dictionary.Keys.Uint(8), _ton.Dictionary.Values.Cell())]);
        const farmDataAccrued = /* @__PURE__ */ new Map();
        if (dict) {
          for (const poolIndex of dict.keys()) {
            const cell = dict.get(poolIndex);
            if (cell === void 0) {
              throw new Error(
                `Failed to parse farmDataAccrued from dict: ${dict}`
              );
            }
            const slice = cell.beginParse();
            const accruedData = {
              depositedNanorewards: slice.loadUintBig(150),
              accruedPerUnitNanorewards: slice.loadUintBig(150),
              accruedFeeNanorewards: slice.loadUintBig(150),
              claimedNanorewards: slice.loadUintBig(150),
              claimedFeeNanorewards: slice.loadUintBig(150),
              accruedNanorewards: slice.loadUintBig(150),
              lastUpdateTime: slice.loadUintBig(64)
            };
            farmDataAccrued.set(poolIndex, accruedData);
          }
        }
        return farmDataAccrued;
      })(),
      farmDataParameters: (() => {
        const dict = _optionalChain([result, 'access', _9 => _9.stack, 'access', _10 => _10.readCellOpt, 'call', _11 => _11(), 'optionalAccess', _12 => _12.asSlice, 'call', _13 => _13(), 'access', _14 => _14.loadDictDirect, 'call', _15 => _15(_ton.Dictionary.Keys.Uint(8), _ton.Dictionary.Values.Cell())]);
        const farmDataParameters = /* @__PURE__ */ new Map();
        if (dict) {
          for (const poolIndex of dict.keys()) {
            const cell = dict.get(poolIndex);
            if (cell === void 0) {
              throw new Error(
                `Failed to parse farmDataParameters from dict: ${dict}`
              );
            }
            const slice = cell.beginParse();
            const parametersData = {
              adminFee: slice.loadUintBig(16),
              nanorewardsPer24h: slice.loadUintBig(150),
              unrestrictedDepositRewards: slice.loadBit(),
              rewardTokenWallet: slice.loadAddress(),
              canChangeFee: slice.loadBit(),
              status: slice.loadUint(8),
              rampDays: version.major === 3 && version.minor === 2 ? slice.loadUint(16) : null
            };
            farmDataParameters.set(poolIndex, parametersData);
          }
        }
        return farmDataParameters;
      })()
    };
  }
}, _class.__initStatic(), _class.__initStatic2(), _class);



exports.FarmNftMinterV3 = FarmNftMinterV3;
//# sourceMappingURL=chunk-KMDPQX63.cjs.map