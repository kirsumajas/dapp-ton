"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;


var _chunkJLYOJWE3cjs = require('./chunk-JLYOJWE3.cjs');


var _chunkIIMQROIVcjs = require('./chunk-IIMQROIV.cjs');

// src/contracts/farm/v1/FarmNftItemV1.ts



var _ton = require('@ton/ton');
var FarmNftItemV1 = (_class = class _FarmNftItemV1 extends _chunkIIMQROIVcjs.Contract {
  static __initStatic() {this.version = _chunkJLYOJWE3cjs.FARM_VERSION.v1}
  static __initStatic2() {this.gasConstants = {
    claimRewards: _ton.toNano.call(void 0, "0.3"),
    unstake: _ton.toNano.call(void 0, "0.4"),
    destroy: _ton.toNano.call(void 0, "0.05")
  }}
  
  constructor(address, { gasConstants, ...options } = {}) {
    super(address, options);
    this.gasConstants = {
      ..._FarmNftItemV1.gasConstants,
      ...gasConstants
    };
  }
  async createClaimRewardsBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkJLYOJWE3cjs.FARM_OP_CODES.CLAIM_REWARDS, 32).storeUint(BigInt(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _ => _.queryId]), () => ( 0))), 64).endCell();
  }
  /**
   * Build all data required to execute a `claim_rewards` transaction.
   *
   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} all data required to execute a `claim_rewards` transaction.
   */
  async getClaimRewardsTxParams(provider, params) {
    const to = this.address;
    const body = await this.createClaimRewardsBody({
      queryId: _optionalChain([params, 'optionalAccess', _2 => _2.queryId])
    });
    const value = BigInt(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _3 => _3.gasAmount]), () => ( this.gasConstants.claimRewards)));
    return { to, value, body };
  }
  async sendClaimRewards(provider, via, params) {
    const txParams = await this.getClaimRewardsTxParams(provider, params);
    return via.send(txParams);
  }
  async createUnstakeBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkJLYOJWE3cjs.FARM_OP_CODES.UNSTAKE, 32).storeUint(BigInt(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _4 => _4.queryId]), () => ( 0))), 64).endCell();
  }
  /**
   * Build all data required to execute a `unstake` transaction.
   *
   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} all data required to execute a `unstake` transaction.
   */
  async getUnstakeTxParams(provider, params) {
    const to = this.address;
    const body = await this.createUnstakeBody({
      queryId: _optionalChain([params, 'optionalAccess', _5 => _5.queryId])
    });
    const value = BigInt(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _6 => _6.gasAmount]), () => ( this.gasConstants.unstake)));
    return { to, value, body };
  }
  async sendUnstake(provider, via, params) {
    const txParams = await this.getUnstakeTxParams(provider, params);
    return via.send(txParams);
  }
  /**
   * @returns structure containing current state of the farm NFT
   *
   * @property {number} status Status of the contract: uninitialized `0`, active `1`, unstaked `2`, claiming `3`
   * @property {boolean} isSoulbound If nft is soulbound
   * @property {bigint} stakedTokens Amount of staked tokens
   * @property {bigint} claimedPerUnitNanorewards `accrued_per_unit_nanorewards` at the time the user made the stake or last claimed rewards
   */
  async getFarmingData(provider) {
    const result = await provider.get("get_farming_data", []);
    return {
      status: result.stack.readNumber(),
      isSoulbound: result.stack.readBoolean(),
      stakedTokens: result.stack.readBigNumber(),
      claimedPerUnitNanorewards: result.stack.readBigNumber()
    };
  }
}, _class.__initStatic(), _class.__initStatic2(), _class);



exports.FarmNftItemV1 = FarmNftItemV1;
//# sourceMappingURL=chunk-T4T7FGFZ.cjs.map