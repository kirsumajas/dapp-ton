import {
  pTON_VERSION
} from "./chunk-MEGJZKYP.js";
import {
  PoolV1
} from "./chunk-AH25BT4Z.js";
import {
  DEX_OP_CODES,
  ROUTER_ADDRESS
} from "./chunk-G6J4NHH6.js";
import {
  JettonMinter
} from "./chunk-S2MQPWHB.js";
import {
  Contract
} from "./chunk-3QLJQGLC.js";
import {
  HOLE_ADDRESS
} from "./chunk-BZOLUFTK.js";
import {
  DEX_VERSION
} from "./chunk-4KVHWM75.js";
import {
  UnmatchedPtonVersion
} from "./chunk-VGVCKGFT.js";
import {
  createJettonTransferMessage
} from "./chunk-5Z5Z5A3U.js";
import {
  toAddress
} from "./chunk-HNMPFVZW.js";

// src/contracts/dex/v1/RouterV1.ts
import {
  address,
  beginCell,
  toNano
} from "@ton/ton";
var RouterV1 = class _RouterV1 extends Contract {
  static version = DEX_VERSION.v1;
  static address = address(ROUTER_ADDRESS);
  static gasConstants = {
    swapJettonToJetton: {
      gasAmount: toNano("0.22"),
      forwardGasAmount: toNano("0.175")
    },
    swapJettonToTon: {
      gasAmount: toNano("0.17"),
      forwardGasAmount: toNano("0.125")
    },
    swapTonToJetton: {
      forwardGasAmount: toNano("0.185")
    },
    provideLpJetton: {
      gasAmount: toNano("0.3"),
      forwardGasAmount: toNano("0.24")
    },
    provideLpTon: {
      forwardGasAmount: toNano("0.26")
    }
  };
  gasConstants;
  constructor(address2 = _RouterV1.address, { gasConstants, ...options } = {}) {
    super(address2, options);
    this.gasConstants = {
      ..._RouterV1.gasConstants,
      ...gasConstants
    };
  }
  async createSwapBody(params) {
    const builder = beginCell();
    builder.storeUint(DEX_OP_CODES.SWAP, 32);
    builder.storeAddress(toAddress(params.askJettonWalletAddress));
    builder.storeCoins(BigInt(params.minAskAmount));
    builder.storeAddress(toAddress(params.userWalletAddress));
    const referralAddress = this.maybeReferralAddress(params.referralAddress);
    if (referralAddress) {
      builder.storeUint(1, 1);
      builder.storeAddress(referralAddress);
    } else {
      builder.storeUint(0, 1);
    }
    return builder.endCell();
  }
  /**
   * Build all data required to execute a jetton to jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message
   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens
   *
   * @returns {SenderArguments} data required to execute a jetton `swap` transaction
   */
  async getSwapJettonToJettonTxParams(provider, params) {
    const [offerJettonWalletAddress, askJettonWalletAddress] = await Promise.all([
      provider.open(JettonMinter.create(params.offerJettonAddress)).getWalletAddress(params.userWalletAddress),
      provider.open(JettonMinter.create(params.askJettonAddress)).getWalletAddress(this.address)
    ]);
    const forwardPayload = await this.createSwapBody({
      userWalletAddress: params.userWalletAddress,
      minAskAmount: params.minAskAmount,
      askJettonWalletAddress,
      referralAddress: params.referralAddress
    });
    const forwardTonAmount = BigInt(
      params.forwardGasAmount ?? this.gasConstants.swapJettonToJetton.forwardGasAmount
    );
    const body = createJettonTransferMessage({
      queryId: params.queryId ?? 0,
      amount: params.offerAmount,
      destination: this.address,
      responseDestination: params.transferExcessAddress ?? params.userWalletAddress,
      customPayload: params.jettonCustomPayload,
      forwardTonAmount,
      forwardPayload
    });
    const value = BigInt(
      params.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount
    );
    return {
      to: offerJettonWalletAddress,
      value,
      body
    };
  }
  async sendSwapJettonToJetton(provider, via, params) {
    const txParams = await this.getSwapJettonToJettonTxParams(provider, params);
    return via.send(txParams);
  }
  /**
   * Build all data required to execute a jetton to ton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
   * @param {PtonV1} params.proxyTon - Proxy ton contract
   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message
   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens
   *
   * @returns {SenderArguments} data required to execute a jetton `swap` transaction
   */
  async getSwapJettonToTonTxParams(provider, params) {
    this.assertProxyTon(params.proxyTon);
    return await this.getSwapJettonToJettonTxParams(provider, {
      ...params,
      askJettonAddress: params.proxyTon.address,
      gasAmount: params.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,
      forwardGasAmount: params.forwardGasAmount ?? this.gasConstants.swapJettonToTon.forwardGasAmount
    });
  }
  async sendSwapJettonToTon(provider, via, params) {
    const txParams = await this.getSwapJettonToTonTxParams(provider, params);
    return via.send(txParams);
  }
  /**
   * Build all data required to execute a ton to jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {PtonV1} params.proxyTon - Proxy ton contract
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {bigint | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)
   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address
   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} data required to execute a ton to jetton `swap` transaction
   */
  async getSwapTonToJettonTxParams(provider, params) {
    this.assertProxyTon(params.proxyTon);
    const askJettonWalletAddress = await provider.open(JettonMinter.create(params.askJettonAddress)).getWalletAddress(this.address);
    const forwardPayload = await this.createSwapBody({
      userWalletAddress: params.userWalletAddress,
      minAskAmount: params.minAskAmount,
      askJettonWalletAddress,
      referralAddress: params.referralAddress
    });
    const forwardTonAmount = BigInt(
      params.forwardGasAmount ?? this.gasConstants.swapTonToJetton.forwardGasAmount
    );
    return await provider.open(params.proxyTon).getTonTransferTxParams({
      queryId: params.queryId ?? 0,
      tonAmount: params.offerAmount,
      destinationAddress: this.address,
      refundAddress: params.userWalletAddress,
      forwardPayload,
      forwardTonAmount
    });
  }
  async sendSwapTonToJetton(provider, via, params) {
    const txParams = await this.getSwapTonToJettonTxParams(provider, params);
    return via.send(txParams);
  }
  async createProvideLiquidityBody(params) {
    return beginCell().storeUint(DEX_OP_CODES.PROVIDE_LP, 32).storeAddress(toAddress(params.routerWalletAddress)).storeCoins(BigInt(params.minLpOut)).endCell();
  }
  /**
   * Collect all data required to execute a jetton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {bigint | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)
   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message
   *
   * @returns {SenderArguments} data required to execute a jetton `provide_lp` transaction
   */
  async getProvideLiquidityJettonTxParams(provider, params) {
    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([
      provider.open(JettonMinter.create(params.sendTokenAddress)).getWalletAddress(params.userWalletAddress),
      provider.open(JettonMinter.create(params.otherTokenAddress)).getWalletAddress(this.address)
    ]);
    const forwardPayload = await this.createProvideLiquidityBody({
      routerWalletAddress,
      minLpOut: params.minLpOut
    });
    const forwardTonAmount = BigInt(
      params.forwardGasAmount ?? this.gasConstants.provideLpJetton.forwardGasAmount
    );
    const body = createJettonTransferMessage({
      queryId: params.queryId ?? 0,
      amount: params.sendAmount,
      destination: this.address,
      responseDestination: params.transferExcessAddress ?? params.userWalletAddress,
      customPayload: params.jettonCustomPayload,
      forwardTonAmount,
      forwardPayload
    });
    const value = BigInt(
      params.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount
    );
    return {
      to: jettonWalletAddress,
      value,
      body
    };
  }
  async sendProvideLiquidityJetton(provider, via, params) {
    const txParams = await this.getProvideLiquidityJettonTxParams(
      provider,
      params
    );
    return via.send(txParams);
  }
  /**
   * Collect all data required to execute a proxy ton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {PtonV1} params.proxyTon - proxy ton contract
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {bigint | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)
   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   *
   * @returns {SenderArguments} data required to execute a proxy ton `provide_lp` transaction
   */
  async getProvideLiquidityTonTxParams(provider, params) {
    this.assertProxyTon(params.proxyTon);
    const routerWalletAddress = await provider.open(JettonMinter.create(params.otherTokenAddress)).getWalletAddress(this.address);
    const forwardPayload = await this.createProvideLiquidityBody({
      routerWalletAddress,
      minLpOut: params.minLpOut
    });
    const forwardTonAmount = BigInt(
      params.forwardGasAmount ?? this.gasConstants.provideLpTon.forwardGasAmount
    );
    return await provider.open(params.proxyTon).getTonTransferTxParams({
      queryId: params.queryId ?? 0,
      tonAmount: params.sendAmount,
      destinationAddress: this.address,
      refundAddress: params.userWalletAddress,
      forwardPayload,
      forwardTonAmount
    });
  }
  async sendProvideLiquidityTon(provider, via, params) {
    const txParams = await this.getProvideLiquidityTonTxParams(
      provider,
      params
    );
    return via.send(txParams);
  }
  assertProxyTon(proxyTon) {
    if (proxyTon.version !== pTON_VERSION.v1) {
      throw new UnmatchedPtonVersion({
        expected: pTON_VERSION.v1,
        received: proxyTon.version
      });
    }
  }
  /**
   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.
   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.
   *
   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton
   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton
   *
   * @returns {Address} an address of a pool for a specified pair of assets.
   */
  async getPoolAddress(provider, params) {
    const result = await provider.get("get_pool_address", [
      {
        type: "slice",
        cell: beginCell().storeAddress(toAddress(params.token0)).endCell()
      },
      {
        type: "slice",
        cell: beginCell().storeAddress(toAddress(params.token1)).endCell()
      }
    ]);
    return result.stack.readAddress();
  }
  /**
   * @param {Address | string} params.token0 - The address of the first Jetton minter
   * @param {Address | string} params.token1 - The address of the second Jetton minter
   *
   * @returns {Address} an address of a pool for a specified pair of assets.
   */
  async getPoolAddressByJettonMinters(provider, params) {
    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([
      provider.open(JettonMinter.create(params.token0)).getWalletAddress(this.address),
      provider.open(JettonMinter.create(params.token1)).getWalletAddress(this.address)
    ]);
    const poolAddress = await this.getPoolAddress(provider, {
      token0: jetton0WalletAddress,
      token1: jetton1WalletAddress
    });
    return poolAddress;
  }
  /**
   * @param {Address | string} params.token0 - The address of the first Jetton minter
   * @param {Address | string} params.token1 - The address of the second Jetton minter
   *
   * @returns {PoolV1} object for a pool with specified Jetton token addresses.
   */
  async getPool(provider, params) {
    const poolAddress = await this.getPoolAddressByJettonMinters(provider, {
      token0: params.token0,
      token1: params.token1
    });
    return PoolV1.create(poolAddress);
  }
  /**
   * @returns current state of the router.
   */
  async getRouterData(provider) {
    const result = await provider.get("get_router_data", []);
    return {
      isLocked: result.stack.readBoolean(),
      adminAddress: result.stack.readAddress(),
      tempUpgrade: result.stack.readCell(),
      poolCode: result.stack.readCell(),
      jettonLpWalletCode: result.stack.readCell(),
      lpAccountCode: result.stack.readCell()
    };
  }
  maybeReferralAddress(referralAddress) {
    if (!referralAddress) return null;
    const referralAddressParsed = toAddress(referralAddress);
    if (referralAddressParsed.equals(HOLE_ADDRESS)) return null;
    return referralAddressParsed;
  }
};

export {
  RouterV1
};
//# sourceMappingURL=chunk-F2AUJD5Q.js.map