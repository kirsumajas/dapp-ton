"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } var _class;


var _chunkJLYOJWE3cjs = require('./chunk-JLYOJWE3.cjs');


var _chunkWF6EZ2CWcjs = require('./chunk-WF6EZ2CW.cjs');


var _chunkVJSHCTQ7cjs = require('./chunk-VJSHCTQ7.cjs');


var _chunkIIMQROIVcjs = require('./chunk-IIMQROIV.cjs');


var _chunkKBINKP7Dcjs = require('./chunk-KBINKP7D.cjs');

// src/contracts/farm/v1/FarmNftMinterV1.ts



var _ton = require('@ton/ton');
var FarmNftMinterV1 = (_class = class _FarmNftMinterV1 extends _chunkIIMQROIVcjs.Contract {
  static __initStatic() {this.version = _chunkJLYOJWE3cjs.FARM_VERSION.v1}
  static __initStatic2() {this.gasConstants = {
    stake: _ton.toNano.call(void 0, "0.3"),
    stakeForward: _ton.toNano.call(void 0, "0.25")
  }}
  
  constructor(address, { gasConstants, ...options } = {}) {
    super(address, options);
    this.gasConstants = {
      ..._FarmNftMinterV1.gasConstants,
      ...gasConstants
    };
  }
  async createStakeBody() {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkJLYOJWE3cjs.FARM_OP_CODES.STAKE, 32).endCell();
  }
  /**
   * Build all data required to execute a jetton `stake` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
   * @param {bigint | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)
   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)
   * @param {bigint | number | undefined} params.queryId - Optional; query id
   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens
   *
   * @returns {SenderArguments} containing all data required to execute a jetton `stake` transaction
   */
  async getStakeTxParams(provider, params) {
    const [jettonWalletAddress, forwardPayload] = await Promise.all([
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.jettonAddress)).getWalletAddress(params.userWalletAddress),
      this.createStakeBody()
    ]);
    const forwardTonAmount = BigInt(
      _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.stakeForward))
    );
    const body = _chunkKBINKP7Dcjs.createJettonTransferMessage.call(void 0, {
      queryId: _nullishCoalesce(params.queryId, () => ( 0)),
      amount: params.jettonAmount,
      destination: this.address,
      responseDestination: _nullishCoalesce(params.transferExcessAddress, () => ( params.userWalletAddress)),
      forwardTonAmount,
      forwardPayload
    });
    const value = BigInt(_nullishCoalesce(params.gasAmount, () => ( this.gasConstants.stake)));
    return {
      to: jettonWalletAddress,
      value,
      body
    };
  }
  async sendStake(provider, via, params) {
    const txParams = await this.getStakeTxParams(provider, params);
    return via.send(txParams);
  }
  /**
   * @returns structure containing current state of the minter
   *
   * @property {bigint} nextItemIndex - Index of the next nft in this collection
   * @property {bigint} lastUpdateTime - Last time farming values were updated
   * @property {number} status - Status of the contract: uninitialized `0`, active `1`, paused `3`
   * @property {bigint} depositedNanorewards - Deposited rewards in nanounits
   * @property {bigint} currentStakedTokens - Number of staked tokens in basic token units
   * @property {bigint} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit
   * @property {bigint} accruedNanorewards - Total number of accrued rewards in nanounits
   * @property {bigint} claimedNanorewards - Number of claimed rewards in nanounits
   * @property {bigint} contractUniqueId - Minter id
   * @property {bigint} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits
   * @property {boolean} soulboundItems - Whether minted NFTs are soulbound
   * @property {bigint} minStakeTime - Minimum staking time
   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet
   * @property {Address} rewardTokenWallet - Minter's reward jetton wallet
   */
  async getFarmingMinterData(provider) {
    const result = await provider.get("get_farming_minter_data", []);
    return {
      nextItemIndex: result.stack.readBigNumber(),
      lastUpdateTime: result.stack.readBigNumber(),
      status: result.stack.readNumber(),
      depositedNanorewards: result.stack.readBigNumber(),
      currentStakedTokens: result.stack.readBigNumber(),
      accruedPerUnitNanorewards: result.stack.readBigNumber(),
      accruedNanorewards: result.stack.readBigNumber(),
      claimedNanorewards: result.stack.readBigNumber(),
      contractUniqueId: result.stack.readBigNumber(),
      nanorewardsPer24h: result.stack.readBigNumber(),
      soulboundItems: result.stack.readBoolean(),
      minStakeTime: result.stack.readBigNumber(),
      stakingTokenWallet: result.stack.readAddress(),
      rewardTokenWallet: result.stack.readAddress()
    };
  }
  /**
   * @returns {Address} address of minter for staking jetton that is used for farming
   */
  async getStakingJettonAddress(provider) {
    const { stakingTokenWallet: stakingTokenWalletAddress } = await this.getFarmingMinterData(provider);
    const { jettonMasterAddress } = await provider.open(_chunkVJSHCTQ7cjs.JettonWallet.create(stakingTokenWalletAddress)).getWalletData();
    return jettonMasterAddress;
  }
}, _class.__initStatic(), _class.__initStatic2(), _class);



exports.FarmNftMinterV1 = FarmNftMinterV1;
//# sourceMappingURL=chunk-Q27FLQK6.cjs.map