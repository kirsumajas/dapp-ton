"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } var _class;

var _chunkRPU6RIXMcjs = require('./chunk-RPU6RIXM.cjs');


var _chunkF6QEZUEHcjs = require('./chunk-F6QEZUEH.cjs');


var _chunkI4SOZEKKcjs = require('./chunk-I4SOZEKK.cjs');



var _chunkC3OQGEQIcjs = require('./chunk-C3OQGEQI.cjs');


var _chunkAZDNTOBWcjs = require('./chunk-AZDNTOBW.cjs');


var _chunkWF6EZ2CWcjs = require('./chunk-WF6EZ2CW.cjs');


var _chunkIIMQROIVcjs = require('./chunk-IIMQROIV.cjs');


var _chunkC4BS7O5Tcjs = require('./chunk-C4BS7O5T.cjs');


var _chunkZJQ75LD3cjs = require('./chunk-ZJQ75LD3.cjs');


var _chunkRE676LGAcjs = require('./chunk-RE676LGA.cjs');


var _chunkKBINKP7Dcjs = require('./chunk-KBINKP7D.cjs');


var _chunkQBYZPWDOcjs = require('./chunk-QBYZPWDO.cjs');

// src/contracts/dex/v2_1/router/BaseRouterV2_1.ts




var _ton = require('@ton/ton');
var BaseRouterV2_1 = (_class = class _BaseRouterV2_1 extends _chunkIIMQROIVcjs.Contract {
  static __initStatic() {this.version = _chunkZJQ75LD3cjs.DEX_VERSION.v2_1}
  static __initStatic2() {this.gasConstants = {
    swapJettonToJetton: {
      gasAmount: _ton.toNano.call(void 0, "0.3"),
      forwardGasAmount: _ton.toNano.call(void 0, "0.24")
    },
    swapJettonToTon: {
      gasAmount: _ton.toNano.call(void 0, "0.3"),
      forwardGasAmount: _ton.toNano.call(void 0, "0.24")
    },
    swapTonToJetton: {
      forwardGasAmount: _ton.toNano.call(void 0, "0.3")
    },
    provideLpJetton: {
      gasAmount: _ton.toNano.call(void 0, "0.3"),
      forwardGasAmount: _ton.toNano.call(void 0, "0.235")
    },
    provideLpTon: {
      forwardGasAmount: _ton.toNano.call(void 0, "0.3")
    },
    singleSideProvideLpJetton: {
      gasAmount: _ton.toNano.call(void 0, "1"),
      forwardGasAmount: _ton.toNano.call(void 0, "0.8")
    },
    singleSideProvideLpTon: {
      forwardGasAmount: _ton.toNano.call(void 0, "0.8")
    }
  }}
  
  
  constructor(address, { gasConstants, txDeadline, ...options } = {}) {
    super(address, options);
    if (this.address.equals(_ton.Address.parse(_chunkAZDNTOBWcjs.ROUTER_ADDRESS))) {
      throw Error(
        [
          "You are trying to create an instance v2.1 Router with a v1 address",
          "Please use the appropriate class for the v1 Router. Otherwise, all the funds will be permanently lost."
        ].join("\n")
      );
    }
    this.gasConstants = {
      ..._BaseRouterV2_1.gasConstants,
      ...gasConstants
    };
    this.txDeadline = _nullishCoalesce(txDeadline, () => ( _chunkC3OQGEQIcjs.TX_DEADLINE));
  }
  async createSwapBody(params) {
    if (params.referralValue && (BigInt(params.referralValue) < 0 || BigInt(params.referralValue) > 100)) {
      throw Error(`'referralValue' should be in range [0, 100] BPS`);
    }
    return _ton.beginCell.call(void 0, ).storeUint(_chunkC3OQGEQIcjs.DEX_OP_CODES.SWAP, 32).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.askJettonWalletAddress)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.refundAddress)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, _nullishCoalesce(params.excessesAddress, () => ( params.refundAddress)))).storeUint(_nullishCoalesce(params.deadline, () => ( this.defaultDeadline)), 64).storeRef(
      _ton.beginCell.call(void 0, ).storeCoins(BigInt(params.minAskAmount)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.receiverAddress)).storeCoins(BigInt(_nullishCoalesce(params.dexCustomPayloadForwardGasAmount, () => ( 0)))).storeMaybeRef(params.dexCustomPayload).storeCoins(BigInt(_nullishCoalesce(params.refundForwardGasAmount, () => ( 0)))).storeMaybeRef(params.refundPayload).storeUint(BigInt(_nullishCoalesce(params.referralValue, () => ( 10))), 16).storeAddress(this.maybeReferralAddress(params.referralAddress)).endCell()
    ).endCell();
  }
  async createCrossSwapBody(params) {
    if (params.referralValue && (BigInt(params.referralValue) < 0 || BigInt(params.referralValue) > 100)) {
      throw Error(`'referralValue' should be in range [0, 100] BPS`);
    }
    return _ton.beginCell.call(void 0, ).storeUint(_chunkC3OQGEQIcjs.DEX_OP_CODES.CROSS_SWAP, 32).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.askJettonWalletAddress)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.refundAddress)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, _nullishCoalesce(params.excessesAddress, () => ( params.refundAddress)))).storeUint(_nullishCoalesce(params.deadline, () => ( this.defaultDeadline)), 64).storeRef(
      _ton.beginCell.call(void 0, ).storeCoins(BigInt(params.minAskAmount)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.receiverAddress)).storeCoins(BigInt(_nullishCoalesce(params.dexCustomPayloadForwardGasAmount, () => ( 0)))).storeMaybeRef(params.dexCustomPayload).storeCoins(BigInt(_nullishCoalesce(params.refundForwardGasAmount, () => ( 0)))).storeMaybeRef(params.refundPayload).storeUint(BigInt(_nullishCoalesce(params.referralValue, () => ( 10))), 16).storeAddress(this.maybeReferralAddress(params.referralAddress)).endCell()
    ).endCell();
  }
  async getSwapJettonToJettonTxParams(provider, params) {
    const contractAddress = this.address;
    const [offerJettonWalletAddress, askJettonWalletAddress] = await Promise.all([
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.offerJettonAddress)).getWalletAddress(params.userWalletAddress),
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.askJettonAddress)).getWalletAddress(contractAddress)
    ]);
    const forwardTonAmount = BigInt(
      _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.swapJettonToJetton.forwardGasAmount))
    );
    const forwardPayload = await this.createSwapBody({
      askJettonWalletAddress,
      receiverAddress: _nullishCoalesce(params.receiverAddress, () => ( params.userWalletAddress)),
      minAskAmount: params.minAskAmount,
      refundAddress: _nullishCoalesce(params.refundAddress, () => ( params.userWalletAddress)),
      excessesAddress: params.excessesAddress,
      referralAddress: params.referralAddress,
      referralValue: params.referralValue,
      dexCustomPayload: params.dexCustomPayload,
      dexCustomPayloadForwardGasAmount: params.dexCustomPayloadForwardGasAmount,
      refundPayload: params.refundPayload,
      refundForwardGasAmount: params.refundForwardGasAmount,
      deadline: params.deadline
    });
    const body = _chunkKBINKP7Dcjs.createJettonTransferMessage.call(void 0, {
      queryId: _nullishCoalesce(params.queryId, () => ( 0)),
      amount: params.offerAmount,
      destination: contractAddress,
      responseDestination: _nullishCoalesce(params.transferExcessAddress, () => ( params.userWalletAddress)),
      customPayload: params.jettonCustomPayload,
      forwardTonAmount,
      forwardPayload
    });
    const value = BigInt(
      _nullishCoalesce(params.gasAmount, () => ( this.gasConstants.swapJettonToJetton.gasAmount))
    );
    return {
      to: offerJettonWalletAddress,
      value,
      body
    };
  }
  async sendSwapJettonToJetton(provider, via, params) {
    const txParams = await this.getSwapJettonToJettonTxParams(provider, params);
    return via.send(txParams);
  }
  async getSwapJettonToTonTxParams(provider, params) {
    this.assertProxyTon(params.proxyTon);
    return await this.getSwapJettonToJettonTxParams(provider, {
      ...params,
      askJettonAddress: params.proxyTon.address,
      gasAmount: _nullishCoalesce(params.gasAmount, () => ( this.gasConstants.swapJettonToTon.gasAmount)),
      forwardGasAmount: _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.swapJettonToTon.forwardGasAmount))
    });
  }
  async sendSwapJettonToTon(provider, via, params) {
    const txParams = await this.getSwapJettonToTonTxParams(provider, params);
    return via.send(txParams);
  }
  async getSwapTonToJettonTxParams(provider, params) {
    this.assertProxyTon(params.proxyTon);
    const contractAddress = this.address;
    const askJettonWalletAddress = await provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.askJettonAddress)).getWalletAddress(contractAddress);
    const forwardPayload = await this.createSwapBody({
      askJettonWalletAddress,
      receiverAddress: _nullishCoalesce(params.receiverAddress, () => ( params.userWalletAddress)),
      minAskAmount: params.minAskAmount,
      refundAddress: _nullishCoalesce(params.refundAddress, () => ( params.userWalletAddress)),
      excessesAddress: params.excessesAddress,
      referralAddress: params.referralAddress,
      referralValue: params.referralValue,
      dexCustomPayload: params.dexCustomPayload,
      dexCustomPayloadForwardGasAmount: params.dexCustomPayloadForwardGasAmount,
      refundPayload: params.refundPayload,
      refundForwardGasAmount: params.refundForwardGasAmount,
      deadline: params.deadline
    });
    const forwardTonAmount = BigInt(
      _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.swapTonToJetton.forwardGasAmount))
    );
    return await provider.open(params.proxyTon).getTonTransferTxParams({
      queryId: _nullishCoalesce(params.queryId, () => ( 0)),
      tonAmount: params.offerAmount,
      destinationAddress: contractAddress,
      refundAddress: params.userWalletAddress,
      forwardPayload,
      forwardTonAmount
    });
  }
  async sendSwapTonToJetton(provider, via, params) {
    const txParams = await this.getSwapTonToJettonTxParams(provider, params);
    return via.send(txParams);
  }
  async createProvideLiquidityBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkC3OQGEQIcjs.DEX_OP_CODES.PROVIDE_LP, 32).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.routerWalletAddress)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.refundAddress)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, _nullishCoalesce(params.excessesAddress, () => ( params.refundAddress)))).storeUint(_nullishCoalesce(params.deadline, () => ( this.defaultDeadline)), 64).storeRef(
      _ton.beginCell.call(void 0, ).storeCoins(BigInt(params.minLpOut)).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.receiverAddress)).storeUint(params.bothPositive ? 1 : 0, 1).storeCoins(BigInt(_nullishCoalesce(params.dexCustomPayloadForwardGasAmount, () => ( 0)))).storeMaybeRef(params.dexCustomPayload).endCell()
    ).endCell();
  }
  async getProvideLiquidityJettonTxParams(provider, params) {
    return this.implGetProvideLiquidityJettonTxParams(provider, {
      ...params,
      gasAmount: _nullishCoalesce(params.gasAmount, () => ( this.gasConstants.provideLpJetton.gasAmount)),
      forwardGasAmount: _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.provideLpJetton.forwardGasAmount)),
      bothPositive: true
    });
  }
  async sendProvideLiquidityJetton(provider, via, params) {
    const txParams = await this.getProvideLiquidityJettonTxParams(
      provider,
      params
    );
    return via.send(txParams);
  }
  async getSingleSideProvideLiquidityJettonTxParams(provider, params) {
    return this.implGetProvideLiquidityJettonTxParams(provider, {
      ...params,
      gasAmount: _nullishCoalesce(params.gasAmount, () => ( this.gasConstants.singleSideProvideLpJetton.gasAmount)),
      forwardGasAmount: _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.singleSideProvideLpJetton.forwardGasAmount)),
      bothPositive: false
    });
  }
  async sendSingleSideProvideLiquidityJetton(provider, via, params) {
    const txParams = await this.getSingleSideProvideLiquidityJettonTxParams(
      provider,
      params
    );
    return via.send(txParams);
  }
  async implGetProvideLiquidityJettonTxParams(provider, params) {
    const contractAddress = this.address;
    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.sendTokenAddress)).getWalletAddress(params.userWalletAddress),
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.otherTokenAddress)).getWalletAddress(contractAddress)
    ]);
    const forwardPayload = await this.createProvideLiquidityBody({
      routerWalletAddress,
      receiverAddress: _nullishCoalesce(params.receiverAddress, () => ( params.userWalletAddress)),
      minLpOut: params.minLpOut,
      refundAddress: _nullishCoalesce(params.refundAddress, () => ( params.userWalletAddress)),
      excessesAddress: params.excessesAddress,
      dexCustomPayload: params.dexCustomPayload,
      dexCustomPayloadForwardGasAmount: params.dexCustomPayloadForwardGasAmount,
      bothPositive: params.bothPositive,
      deadline: params.deadline
    });
    const forwardTonAmount = BigInt(params.forwardGasAmount);
    const body = _chunkKBINKP7Dcjs.createJettonTransferMessage.call(void 0, {
      queryId: _nullishCoalesce(params.queryId, () => ( 0)),
      amount: params.sendAmount,
      destination: contractAddress,
      responseDestination: _nullishCoalesce(params.transferExcessAddress, () => ( params.userWalletAddress)),
      customPayload: params.jettonCustomPayload,
      forwardTonAmount,
      forwardPayload
    });
    const value = BigInt(params.gasAmount);
    return {
      to: jettonWalletAddress,
      value,
      body
    };
  }
  async getProvideLiquidityTonTxParams(provider, params) {
    return this.implGetProvideLiquidityTonTxParams(provider, {
      ...params,
      forwardGasAmount: _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.provideLpTon.forwardGasAmount)),
      bothPositive: true
    });
  }
  async sendProvideLiquidityTon(provider, via, params) {
    const txParams = await this.getProvideLiquidityTonTxParams(
      provider,
      params
    );
    return via.send(txParams);
  }
  async getSingleSideProvideLiquidityTonTxParams(provider, params) {
    return this.implGetProvideLiquidityTonTxParams(provider, {
      ...params,
      forwardGasAmount: _nullishCoalesce(params.forwardGasAmount, () => ( this.gasConstants.singleSideProvideLpTon.forwardGasAmount)),
      bothPositive: false
    });
  }
  async sendSingleSideProvideLiquidityTon(provider, via, params) {
    const txParams = await this.getSingleSideProvideLiquidityTonTxParams(
      provider,
      params
    );
    return via.send(txParams);
  }
  async implGetProvideLiquidityTonTxParams(provider, params) {
    this.assertProxyTon(params.proxyTon);
    const contractAddress = this.address;
    const routerWalletAddress = await provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.otherTokenAddress)).getWalletAddress(contractAddress);
    const forwardPayload = await this.createProvideLiquidityBody({
      routerWalletAddress,
      receiverAddress: _nullishCoalesce(params.receiverAddress, () => ( params.userWalletAddress)),
      minLpOut: params.minLpOut,
      refundAddress: _nullishCoalesce(params.refundAddress, () => ( params.userWalletAddress)),
      excessesAddress: params.excessesAddress,
      dexCustomPayload: params.dexCustomPayload,
      dexCustomPayloadForwardGasAmount: params.dexCustomPayloadForwardGasAmount,
      bothPositive: params.bothPositive,
      deadline: params.deadline
    });
    const forwardTonAmount = BigInt(params.forwardGasAmount);
    return await provider.open(params.proxyTon).getTonTransferTxParams({
      queryId: _nullishCoalesce(params.queryId, () => ( 0)),
      tonAmount: params.sendAmount,
      destinationAddress: contractAddress,
      refundAddress: params.userWalletAddress,
      forwardPayload,
      forwardTonAmount
    });
  }
  maybeReferralAddress(referralAddress) {
    if (!referralAddress) return null;
    const referralAddressParsed = _chunkQBYZPWDOcjs.toAddress.call(void 0, referralAddress);
    if (referralAddressParsed.equals(_chunkC4BS7O5Tcjs.HOLE_ADDRESS)) return null;
    return referralAddressParsed;
  }
  get defaultDeadline() {
    return Math.floor(Date.now() / 1e3) + this.txDeadline;
  }
  assertProxyTon(proxyTon) {
    if (proxyTon.version !== _chunkI4SOZEKKcjs.pTON_VERSION.v2_1) {
      throw new (0, _chunkRE676LGAcjs.UnmatchedPtonVersion)({
        expected: _chunkI4SOZEKKcjs.pTON_VERSION.v2_1,
        received: proxyTon.version
      });
    }
  }
  async getPoolAddress(provider, params) {
    const result = await provider.get("get_pool_address", [
      {
        type: "slice",
        cell: _ton.beginCell.call(void 0, ).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.token0)).endCell()
      },
      {
        type: "slice",
        cell: _ton.beginCell.call(void 0, ).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.token1)).endCell()
      }
    ]);
    return result.stack.readAddress();
  }
  async getPoolAddressByJettonMinters(provider, params) {
    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.token0)).getWalletAddress(this.address),
      provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.token1)).getWalletAddress(this.address)
    ]);
    const poolAddress = await this.getPoolAddress(provider, {
      token0: jetton0WalletAddress,
      token1: jetton1WalletAddress
    });
    return poolAddress;
  }
  async getPool(provider, params) {
    const poolAddress = await this.getPoolAddressByJettonMinters(
      provider,
      params
    );
    return _chunkF6QEZUEHcjs.BasePoolV2_1.create(poolAddress);
  }
  async getVaultAddress(provider, params) {
    const result = await provider.get("get_vault_address", [
      {
        type: "slice",
        cell: _ton.beginCell.call(void 0, ).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.user)).endCell()
      },
      {
        type: "slice",
        cell: _ton.beginCell.call(void 0, ).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.tokenWallet)).endCell()
      }
    ]);
    return result.stack.readAddress();
  }
  async getVault(provider, params) {
    const tokenMinter = provider.open(_chunkWF6EZ2CWcjs.JettonMinter.create(params.tokenMinter));
    const vaultAddress = await this.getVaultAddress(provider, {
      user: params.user,
      tokenWallet: await tokenMinter.getWalletAddress(this.address)
    });
    return _chunkRPU6RIXMcjs.VaultV2_1.create(vaultAddress);
  }
  async getRouterVersion(provider) {
    const result = await provider.get("get_router_version", []);
    return {
      major: result.stack.readNumber(),
      minor: result.stack.readNumber(),
      development: result.stack.readString()
    };
  }
  async getRouterData(provider) {
    const result = await provider.get("get_router_data", []);
    return {
      routerId: result.stack.readNumber(),
      dexType: result.stack.readString(),
      isLocked: result.stack.readBoolean(),
      adminAddress: result.stack.readAddress(),
      tempUpgrade: result.stack.readCell(),
      poolCode: result.stack.readCell(),
      jettonLpWalletCode: result.stack.readCell(),
      lpAccountCode: result.stack.readCell(),
      vaultCode: result.stack.readCell()
    };
  }
}, _class.__initStatic(), _class.__initStatic2(), _class);



exports.BaseRouterV2_1 = BaseRouterV2_1;
//# sourceMappingURL=chunk-I5N4ORCV.cjs.map