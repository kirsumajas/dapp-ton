{"version":3,"sources":["/Users/paul-n/git/ston-fi/public/sdk-contracts/packages/sdk/dist/chunk-XATUZSYE.cjs","../src/contracts/dex/v1/PoolV1.ts"],"names":[],"mappings":"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","file":"/Users/paul-n/git/ston-fi/public/sdk-contracts/packages/sdk/dist/chunk-XATUZSYE.cjs","sourcesContent":[null,"import {\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { toAddress } from \"../../../utils/toAddress\";\nimport type { ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { JettonWallet } from \"../../core/JettonWallet\";\nimport { DEX_VERSION } from \"../constants\";\nimport { LpAccountV1 } from \"./LpAccountV1\";\nimport { DEX_OP_CODES } from \"./constants\";\n\nexport interface PoolV1Options extends ContractOptions {\n  gasConstants?: Partial<typeof PoolV1.gasConstants>;\n}\n\n/**\n * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.\n * For each pair (e.g. STON/USDT), there is only a single pool contract.\n * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.\n * All the swap/lp calculations are done in the pool contract.\n */\nexport class PoolV1 extends JettonMinter {\n  public static readonly version: DEX_VERSION = DEX_VERSION.v1;\n  public static readonly gasConstants = {\n    collectFees: toNano(\"1.1\"),\n    burn: toNano(\"0.5\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: PoolV1Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...PoolV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createCollectFeesBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.COLLECT_FEES, 32)\n      .storeUint(params?.queryId ?? 0, 64)\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a `collect_fees` transaction.\n   *\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `collect_fees` transaction.\n   */\n  public async getCollectFeeTxParams(\n    provider: ContractProvider,\n    params?: {\n      gasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const to = this.address;\n\n    const body = await this.createCollectFeesBody({\n      queryId: params?.queryId,\n    });\n\n    const value = BigInt(params?.gasAmount ?? this.gasConstants.collectFees);\n\n    return { to, value, body };\n  }\n\n  public async sendCollectFees(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<PoolV1[\"getCollectFeeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getCollectFeeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createBurnBody(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.BURN, 32)\n      .storeUint(params?.queryId ?? 0, 64)\n      .storeCoins(BigInt(params.amount))\n      .storeAddress(toAddress(params.responseAddress))\n      .storeMaybeRef()\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a `burn` transaction.\n   *\n   * @param {bigint | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `burn` transaction.\n   */\n  public async getBurnTxParams(\n    provider: ContractProvider,\n    params: {\n      amount: AmountType;\n      responseAddress: AddressType;\n      gasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const [to, body] = await Promise.all([\n      this.getWalletAddress(provider, params.responseAddress),\n      this.createBurnBody({\n        amount: params.amount,\n        responseAddress: params.responseAddress,\n        queryId: params.queryId,\n      }),\n    ]);\n\n    const value = BigInt(params.gasAmount ?? this.gasConstants.burn);\n\n    return { to, value, body };\n  }\n\n  public async sendBurn(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<PoolV1[\"getBurnTxParams\"]>[1],\n  ) {\n    const txParams = await this.getBurnTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Estimate the expected result of the amount of jettonWallet tokens swapped to the other token of the pool\n   *\n   * @param {bigint | number} params.amount - Amount of tokens to swap (in basic token units)\n   * @param {Address | string} params.jettonWallet - jetton wallet address (owned by the router)\n   *\n   * @returns structure with the expected result of a token swap\n   */\n  public async getExpectedOutputs(\n    provider: ContractProvider,\n    params: {\n      amount: AmountType;\n      jettonWallet: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_expected_outputs\", [\n      { type: \"int\", value: BigInt(params.amount) },\n      {\n        type: \"slice\",\n        cell: beginCell()\n          .storeAddress(toAddress(params.jettonWallet))\n          .endCell(),\n      },\n    ]);\n\n    return {\n      jettonToReceive: result.stack.readBigNumber(),\n      protocolFeePaid: result.stack.readBigNumber(),\n      refFeePaid: result.stack.readBigNumber(),\n    };\n  }\n\n  /**\n   * Estimate an expected amount of lp tokens minted when providing liquidity.\n   *\n   * @param {bigint | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)\n   * @param {bigint | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)\n   *\n   * @returns {bigint} an estimated amount of liquidity tokens to be minted\n   */\n  public async getExpectedTokens(\n    provider: ContractProvider,\n    params: {\n      amount0: AmountType;\n      amount1: AmountType;\n    },\n  ) {\n    const result = await provider.get(\"get_expected_tokens\", [\n      { type: \"int\", value: BigInt(params.amount0) },\n      { type: \"int\", value: BigInt(params.amount1) },\n    ]);\n\n    return result.stack.readBigNumber();\n  }\n\n  /**\n   * Estimate expected liquidity freed upon burning liquidity tokens.\n   *\n   * @param {bigint | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)\n   *\n   * @returns structure with expected freed liquidity\n   */\n  public async getExpectedLiquidity(\n    provider: ContractProvider,\n    params: {\n      jettonAmount: AmountType;\n    },\n  ) {\n    const result = await provider.get(\"get_expected_liquidity\", [\n      { type: \"int\", value: BigInt(params.jettonAmount) },\n    ]);\n\n    return {\n      amount0: result.stack.readBigNumber(),\n      amount1: result.stack.readBigNumber(),\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {Address} the lp account address of a user\n   */\n  public async getLpAccountAddress(\n    provider: ContractProvider,\n    params: {\n      ownerAddress: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_lp_account_address\", [\n      {\n        type: \"slice\",\n        cell: beginCell()\n          .storeAddress(toAddress(params.ownerAddress))\n          .endCell(),\n      },\n    ]);\n\n    return result.stack.readAddress();\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {JettonWallet} a JettonWallet instance with address returned by getJettonWalletAddress\n   */\n  public async getJettonWallet(\n    provider: ContractProvider,\n    params: {\n      ownerAddress: AddressType;\n    },\n  ) {\n    const jettonWalletAddress = await this.getWalletAddress(\n      provider,\n      params.ownerAddress,\n    );\n\n    return JettonWallet.create(jettonWalletAddress);\n  }\n\n  /**\n   * @returns structure containing current state of the pool.\n   */\n  public async getPoolData(provider: ContractProvider) {\n    const result = await provider.get(\"get_pool_data\", []);\n\n    return {\n      reserve0: result.stack.readBigNumber(),\n      reserve1: result.stack.readBigNumber(),\n      token0WalletAddress: result.stack.readAddress(),\n      token1WalletAddress: result.stack.readAddress(),\n      lpFee: result.stack.readBigNumber(),\n      protocolFee: result.stack.readBigNumber(),\n      refFee: result.stack.readBigNumber(),\n      protocolFeeAddress: result.stack.readAddress(),\n      collectedToken0ProtocolFee: result.stack.readBigNumber(),\n      collectedToken1ProtocolFee: result.stack.readBigNumber(),\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {LpAccount} object for address returned by getLpAccountAddress\n   */\n  public async getLpAccount(\n    provider: ContractProvider,\n    params: {\n      ownerAddress: AddressType;\n    },\n  ) {\n    const lpAccountAddress = await this.getLpAccountAddress(provider, params);\n\n    return LpAccountV1.create(lpAccountAddress);\n  }\n}\n"]}