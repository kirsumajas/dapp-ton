{"version":3,"sources":["../src/contracts/dex/v1/PoolV1.ts"],"sourcesContent":["import {\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { toAddress } from \"../../../utils/toAddress\";\nimport type { ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { JettonWallet } from \"../../core/JettonWallet\";\nimport { DEX_VERSION } from \"../constants\";\nimport { LpAccountV1 } from \"./LpAccountV1\";\nimport { DEX_OP_CODES } from \"./constants\";\n\nexport interface PoolV1Options extends ContractOptions {\n  gasConstants?: Partial<typeof PoolV1.gasConstants>;\n}\n\n/**\n * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.\n * For each pair (e.g. STON/USDT), there is only a single pool contract.\n * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.\n * All the swap/lp calculations are done in the pool contract.\n */\nexport class PoolV1 extends JettonMinter {\n  public static readonly version: DEX_VERSION = DEX_VERSION.v1;\n  public static readonly gasConstants = {\n    collectFees: toNano(\"1.1\"),\n    burn: toNano(\"0.5\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: PoolV1Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...PoolV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createCollectFeesBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.COLLECT_FEES, 32)\n      .storeUint(params?.queryId ?? 0, 64)\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a `collect_fees` transaction.\n   *\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `collect_fees` transaction.\n   */\n  public async getCollectFeeTxParams(\n    provider: ContractProvider,\n    params?: {\n      gasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const to = this.address;\n\n    const body = await this.createCollectFeesBody({\n      queryId: params?.queryId,\n    });\n\n    const value = BigInt(params?.gasAmount ?? this.gasConstants.collectFees);\n\n    return { to, value, body };\n  }\n\n  public async sendCollectFees(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<PoolV1[\"getCollectFeeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getCollectFeeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createBurnBody(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.BURN, 32)\n      .storeUint(params?.queryId ?? 0, 64)\n      .storeCoins(BigInt(params.amount))\n      .storeAddress(toAddress(params.responseAddress))\n      .storeMaybeRef()\n      .endCell();\n  }\n\n  /**\n   * Build all data required to execute a `burn` transaction.\n   *\n   * @param {bigint | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} all data required to execute a `burn` transaction.\n   */\n  public async getBurnTxParams(\n    provider: ContractProvider,\n    params: {\n      amount: AmountType;\n      responseAddress: AddressType;\n      gasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    const [to, body] = await Promise.all([\n      this.getWalletAddress(provider, params.responseAddress),\n      this.createBurnBody({\n        amount: params.amount,\n        responseAddress: params.responseAddress,\n        queryId: params.queryId,\n      }),\n    ]);\n\n    const value = BigInt(params.gasAmount ?? this.gasConstants.burn);\n\n    return { to, value, body };\n  }\n\n  public async sendBurn(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<PoolV1[\"getBurnTxParams\"]>[1],\n  ) {\n    const txParams = await this.getBurnTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Estimate the expected result of the amount of jettonWallet tokens swapped to the other token of the pool\n   *\n   * @param {bigint | number} params.amount - Amount of tokens to swap (in basic token units)\n   * @param {Address | string} params.jettonWallet - jetton wallet address (owned by the router)\n   *\n   * @returns structure with the expected result of a token swap\n   */\n  public async getExpectedOutputs(\n    provider: ContractProvider,\n    params: {\n      amount: AmountType;\n      jettonWallet: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_expected_outputs\", [\n      { type: \"int\", value: BigInt(params.amount) },\n      {\n        type: \"slice\",\n        cell: beginCell()\n          .storeAddress(toAddress(params.jettonWallet))\n          .endCell(),\n      },\n    ]);\n\n    return {\n      jettonToReceive: result.stack.readBigNumber(),\n      protocolFeePaid: result.stack.readBigNumber(),\n      refFeePaid: result.stack.readBigNumber(),\n    };\n  }\n\n  /**\n   * Estimate an expected amount of lp tokens minted when providing liquidity.\n   *\n   * @param {bigint | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)\n   * @param {bigint | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)\n   *\n   * @returns {bigint} an estimated amount of liquidity tokens to be minted\n   */\n  public async getExpectedTokens(\n    provider: ContractProvider,\n    params: {\n      amount0: AmountType;\n      amount1: AmountType;\n    },\n  ) {\n    const result = await provider.get(\"get_expected_tokens\", [\n      { type: \"int\", value: BigInt(params.amount0) },\n      { type: \"int\", value: BigInt(params.amount1) },\n    ]);\n\n    return result.stack.readBigNumber();\n  }\n\n  /**\n   * Estimate expected liquidity freed upon burning liquidity tokens.\n   *\n   * @param {bigint | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)\n   *\n   * @returns structure with expected freed liquidity\n   */\n  public async getExpectedLiquidity(\n    provider: ContractProvider,\n    params: {\n      jettonAmount: AmountType;\n    },\n  ) {\n    const result = await provider.get(\"get_expected_liquidity\", [\n      { type: \"int\", value: BigInt(params.jettonAmount) },\n    ]);\n\n    return {\n      amount0: result.stack.readBigNumber(),\n      amount1: result.stack.readBigNumber(),\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {Address} the lp account address of a user\n   */\n  public async getLpAccountAddress(\n    provider: ContractProvider,\n    params: {\n      ownerAddress: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_lp_account_address\", [\n      {\n        type: \"slice\",\n        cell: beginCell()\n          .storeAddress(toAddress(params.ownerAddress))\n          .endCell(),\n      },\n    ]);\n\n    return result.stack.readAddress();\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {JettonWallet} a JettonWallet instance with address returned by getJettonWalletAddress\n   */\n  public async getJettonWallet(\n    provider: ContractProvider,\n    params: {\n      ownerAddress: AddressType;\n    },\n  ) {\n    const jettonWalletAddress = await this.getWalletAddress(\n      provider,\n      params.ownerAddress,\n    );\n\n    return JettonWallet.create(jettonWalletAddress);\n  }\n\n  /**\n   * @returns structure containing current state of the pool.\n   */\n  public async getPoolData(provider: ContractProvider) {\n    const result = await provider.get(\"get_pool_data\", []);\n\n    return {\n      reserve0: result.stack.readBigNumber(),\n      reserve1: result.stack.readBigNumber(),\n      token0WalletAddress: result.stack.readAddress(),\n      token1WalletAddress: result.stack.readAddress(),\n      lpFee: result.stack.readBigNumber(),\n      protocolFee: result.stack.readBigNumber(),\n      refFee: result.stack.readBigNumber(),\n      protocolFeeAddress: result.stack.readAddress(),\n      collectedToken0ProtocolFee: result.stack.readBigNumber(),\n      collectedToken1ProtocolFee: result.stack.readBigNumber(),\n    };\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {LpAccount} object for address returned by getLpAccountAddress\n   */\n  public async getLpAccount(\n    provider: ContractProvider,\n    params: {\n      ownerAddress: AddressType;\n    },\n  ) {\n    const lpAccountAddress = await this.getLpAccountAddress(provider, params);\n\n    return LpAccountV1.create(lpAccountAddress);\n  }\n}\n"],"mappings":"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","names":[]}