{"version":3,"sources":["../src/contracts/farm/v1/FarmNftMinterV1.ts"],"sourcesContent":["import {\n  type Address,\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { createJettonTransferMessage } from \"../../../utils/createJettonTransferMessage\";\nimport { Contract, type ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { JettonWallet } from \"../../core/JettonWallet\";\nimport { FARM_OP_CODES, FARM_VERSION } from \"../constants\";\n\nexport interface FarmNftMinterV1Options extends ContractOptions {\n  gasConstants?: Partial<typeof FarmNftMinterV1.gasConstants>;\n}\n\n/**\n * @deprecated `v1` version of the FarmNftMinter contracts is deprecated.\n *\n * Only use this version for get data contract calls.\n * For all other operations, use the latest version of the contract.\n */\nexport class FarmNftMinterV1 extends Contract {\n  public static readonly version: FARM_VERSION = FARM_VERSION.v1;\n\n  public static readonly gasConstants = {\n    stake: toNano(\"0.3\"),\n    stakeForward: toNano(\"0.25\"),\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType,\n    { gasConstants, ...options }: FarmNftMinterV1Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...FarmNftMinterV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createStakeBody(): Promise<Cell> {\n    return beginCell().storeUint(FARM_OP_CODES.STAKE, 32).endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {bigint | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} containing all data required to execute a jetton `stake` transaction\n   */\n  public async getStakeTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      jettonAddress: AddressType;\n      jettonAmount: AmountType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, forwardPayload] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.jettonAddress))\n        .getWalletAddress(params.userWalletAddress),\n      this.createStakeBody(),\n    ]);\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ?? this.gasConstants.stakeForward,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(params.gasAmount ?? this.gasConstants.stake);\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendStake(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<FarmNftMinterV1[\"getStakeTxParams\"]>[1],\n  ) {\n    const txParams = await this.getStakeTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * @returns structure containing current state of the minter\n   *\n   * @property {bigint} nextItemIndex - Index of the next nft in this collection\n   * @property {bigint} lastUpdateTime - Last time farming values were updated\n   * @property {number} status - Status of the contract: uninitialized `0`, active `1`, paused `3`\n   * @property {bigint} depositedNanorewards - Deposited rewards in nanounits\n   * @property {bigint} currentStakedTokens - Number of staked tokens in basic token units\n   * @property {bigint} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n   * @property {bigint} accruedNanorewards - Total number of accrued rewards in nanounits\n   * @property {bigint} claimedNanorewards - Number of claimed rewards in nanounits\n   * @property {bigint} contractUniqueId - Minter id\n   * @property {bigint} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n   * @property {boolean} soulboundItems - Whether minted NFTs are soulbound\n   * @property {bigint} minStakeTime - Minimum staking time\n   * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n   * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n   */\n  public async getFarmingMinterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_farming_minter_data\", []);\n\n    return {\n      nextItemIndex: result.stack.readBigNumber(),\n      lastUpdateTime: result.stack.readBigNumber(),\n      status: result.stack.readNumber(),\n      depositedNanorewards: result.stack.readBigNumber(),\n      currentStakedTokens: result.stack.readBigNumber(),\n      accruedPerUnitNanorewards: result.stack.readBigNumber(),\n      accruedNanorewards: result.stack.readBigNumber(),\n      claimedNanorewards: result.stack.readBigNumber(),\n      contractUniqueId: result.stack.readBigNumber(),\n      nanorewardsPer24h: result.stack.readBigNumber(),\n      soulboundItems: result.stack.readBoolean(),\n      minStakeTime: result.stack.readBigNumber(),\n      stakingTokenWallet: result.stack.readAddress(),\n      rewardTokenWallet: result.stack.readAddress(),\n    };\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton that is used for farming\n   */\n  public async getStakingJettonAddress(\n    provider: ContractProvider,\n  ): Promise<Address> {\n    const { stakingTokenWallet: stakingTokenWalletAddress } =\n      await this.getFarmingMinterData(provider);\n\n    const { jettonMasterAddress } = await provider\n      .open(JettonWallet.create(stakingTokenWalletAddress))\n      .getWalletData();\n\n    return jettonMasterAddress;\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA,EAME;AAAA,EACA;AAAA,OACK;AAmBA,IAAM,kBAAN,MAAM,yBAAwB,SAAS;AAAA,EAC5C,OAAuB,UAAwB,aAAa;AAAA,EAE5D,OAAuB,eAAe;AAAA,IACpC,OAAO,OAAO,KAAK;AAAA,IACnB,cAAc,OAAO,MAAM;AAAA,EAC7B;AAAA,EAEgB;AAAA,EAEhB,YACE,SACA,EAAE,cAAc,GAAG,QAAQ,IAA4B,CAAC,GACxD;AACA,UAAM,SAAS,OAAO;AAEtB,SAAK,eAAe;AAAA,MAClB,GAAG,iBAAgB;AAAA,MACnB,GAAG;AAAA,IACL;AAAA,EACF;AAAA,EAEA,MAAa,kBAAiC;AAC5C,WAAO,UAAU,EAAE,UAAU,cAAc,OAAO,EAAE,EAAE,QAAQ;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,MAAa,iBACX,UACA,QAS0B;AAC1B,UAAM,CAAC,qBAAqB,cAAc,IAAI,MAAM,QAAQ,IAAI;AAAA,MAC9D,SACG,KAAK,aAAa,OAAO,OAAO,aAAa,CAAC,EAC9C,iBAAiB,OAAO,iBAAiB;AAAA,MAC5C,KAAK,gBAAgB;AAAA,IACvB,CAAC;AAED,UAAM,mBAAmB;AAAA,MACvB,OAAO,oBAAoB,KAAK,aAAa;AAAA,IAC/C;AAEA,UAAM,OAAO,4BAA4B;AAAA,MACvC,SAAS,OAAO,WAAW;AAAA,MAC3B,QAAQ,OAAO;AAAA,MACf,aAAa,KAAK;AAAA,MAClB,qBACE,OAAO,yBAAyB,OAAO;AAAA,MACzC;AAAA,MACA;AAAA,IACF,CAAC;AAED,UAAM,QAAQ,OAAO,OAAO,aAAa,KAAK,aAAa,KAAK;AAEhE,WAAO;AAAA,MACL,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAa,UACX,UACA,KACA,QACA;AACA,UAAM,WAAW,MAAM,KAAK,iBAAiB,UAAU,MAAM;AAE7D,WAAO,IAAI,KAAK,QAAQ;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,MAAa,qBAAqB,UAA4B;AAC5D,UAAM,SAAS,MAAM,SAAS,IAAI,2BAA2B,CAAC,CAAC;AAE/D,WAAO;AAAA,MACL,eAAe,OAAO,MAAM,cAAc;AAAA,MAC1C,gBAAgB,OAAO,MAAM,cAAc;AAAA,MAC3C,QAAQ,OAAO,MAAM,WAAW;AAAA,MAChC,sBAAsB,OAAO,MAAM,cAAc;AAAA,MACjD,qBAAqB,OAAO,MAAM,cAAc;AAAA,MAChD,2BAA2B,OAAO,MAAM,cAAc;AAAA,MACtD,oBAAoB,OAAO,MAAM,cAAc;AAAA,MAC/C,oBAAoB,OAAO,MAAM,cAAc;AAAA,MAC/C,kBAAkB,OAAO,MAAM,cAAc;AAAA,MAC7C,mBAAmB,OAAO,MAAM,cAAc;AAAA,MAC9C,gBAAgB,OAAO,MAAM,YAAY;AAAA,MACzC,cAAc,OAAO,MAAM,cAAc;AAAA,MACzC,oBAAoB,OAAO,MAAM,YAAY;AAAA,MAC7C,mBAAmB,OAAO,MAAM,YAAY;AAAA,IAC9C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,wBACX,UACkB;AAClB,UAAM,EAAE,oBAAoB,0BAA0B,IACpD,MAAM,KAAK,qBAAqB,QAAQ;AAE1C,UAAM,EAAE,oBAAoB,IAAI,MAAM,SACnC,KAAK,aAAa,OAAO,yBAAyB,CAAC,EACnD,cAAc;AAEjB,WAAO;AAAA,EACT;AACF;","names":[]}