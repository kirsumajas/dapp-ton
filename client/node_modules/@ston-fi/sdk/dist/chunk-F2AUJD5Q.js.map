{"version":3,"sources":["../src/contracts/dex/v1/RouterV1.ts"],"sourcesContent":["import {\n  type Cell,\n  type ContractProvider,\n  type Sender,\n  type SenderArguments,\n  address,\n  beginCell,\n  toNano,\n} from \"@ton/ton\";\n\nimport type { AddressType, AmountType, QueryIdType } from \"../../../types\";\nimport { createJettonTransferMessage } from \"../../../utils/createJettonTransferMessage\";\nimport { toAddress } from \"../../../utils/toAddress\";\nimport { Contract, type ContractOptions } from \"../../core/Contract\";\nimport { JettonMinter } from \"../../core/JettonMinter\";\nimport { HOLE_ADDRESS } from \"../../core/constants\";\nimport { pTON_VERSION } from \"../../pTON\";\nimport type { AbstractPton } from \"../../pTON/AbstractPton\";\nimport { DEX_VERSION } from \"../constants\";\nimport * as Errors from \"../errors\";\nimport { PoolV1 } from \"./PoolV1\";\nimport { DEX_OP_CODES, ROUTER_ADDRESS } from \"./constants\";\n\nexport interface RouterV1Options extends ContractOptions {\n  gasConstants?: Partial<typeof RouterV1.gasConstants>;\n}\n\n/**\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class RouterV1 extends Contract {\n  public static readonly version: DEX_VERSION = DEX_VERSION.v1;\n  public static readonly address = address(ROUTER_ADDRESS);\n  public static readonly gasConstants = {\n    swapJettonToJetton: {\n      gasAmount: toNano(\"0.22\"),\n      forwardGasAmount: toNano(\"0.175\"),\n    },\n    swapJettonToTon: {\n      gasAmount: toNano(\"0.17\"),\n      forwardGasAmount: toNano(\"0.125\"),\n    },\n    swapTonToJetton: {\n      forwardGasAmount: toNano(\"0.185\"),\n    },\n    provideLpJetton: {\n      gasAmount: toNano(\"0.3\"),\n      forwardGasAmount: toNano(\"0.24\"),\n    },\n    provideLpTon: {\n      forwardGasAmount: toNano(\"0.26\"),\n    },\n  };\n\n  public readonly gasConstants;\n\n  constructor(\n    address: AddressType = RouterV1.address,\n    { gasConstants, ...options }: RouterV1Options = {},\n  ) {\n    super(address, options);\n\n    this.gasConstants = {\n      ...RouterV1.gasConstants,\n      ...gasConstants,\n    };\n  }\n\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    const builder = beginCell();\n\n    builder.storeUint(DEX_OP_CODES.SWAP, 32);\n    builder.storeAddress(toAddress(params.askJettonWalletAddress));\n    builder.storeCoins(BigInt(params.minAskAmount));\n    builder.storeAddress(toAddress(params.userWalletAddress));\n\n    const referralAddress = this.maybeReferralAddress(params.referralAddress);\n\n    if (referralAddress) {\n      builder.storeUint(1, 1);\n      builder.storeAddress(referralAddress);\n    } else {\n      builder.storeUint(0, 1);\n    }\n\n    return builder.endCell();\n  }\n\n  /**\n   * Build all data required to execute a jetton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} data required to execute a jetton `swap` transaction\n   */\n  public async getSwapJettonToJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      offerJettonAddress: AddressType;\n      askJettonAddress: AddressType;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      jettonCustomPayload?: Cell;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [offerJettonWalletAddress, askJettonWalletAddress] =\n      await Promise.all([\n        provider\n          .open(JettonMinter.create(params.offerJettonAddress))\n          .getWalletAddress(params.userWalletAddress),\n        provider\n          .open(JettonMinter.create(params.askJettonAddress))\n          .getWalletAddress(this.address),\n      ]);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.swapJettonToJetton.forwardGasAmount,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      customPayload: params.jettonCustomPayload,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(\n      params.gasAmount ?? this.gasConstants.swapJettonToJetton.gasAmount,\n    );\n\n    return {\n      to: offerJettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendSwapJettonToJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapJettonToJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapJettonToJettonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Build all data required to execute a jetton to ton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {PtonV1} params.proxyTon - Proxy ton contract\n   * @param {bigint | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message\n   * @param {Address | string | undefined} params.transferExcessAddress - Optional; address to transfer excess tokens\n   *\n   * @returns {SenderArguments} data required to execute a jetton `swap` transaction\n   */\n  public async getSwapJettonToTonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      offerJettonAddress: AddressType;\n      proxyTon: AbstractPton;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      jettonCustomPayload?: Cell;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    this.assertProxyTon(params.proxyTon);\n\n    return await this.getSwapJettonToJettonTxParams(provider, {\n      ...params,\n      askJettonAddress: params.proxyTon.address,\n      gasAmount:\n        params.gasAmount ?? this.gasConstants.swapJettonToTon.gasAmount,\n      forwardGasAmount:\n        params.forwardGasAmount ??\n        this.gasConstants.swapJettonToTon.forwardGasAmount,\n    });\n  }\n\n  public async sendSwapJettonToTon(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapJettonToTonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapJettonToTonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {PtonV1} params.proxyTon - Proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {bigint | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {bigint | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string | undefined} params.referralAddress - Optional; Referral address\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a ton to jetton `swap` transaction\n   */\n  public async getSwapTonToJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      proxyTon: AbstractPton;\n      askJettonAddress: AddressType;\n      offerAmount: AmountType;\n      minAskAmount: AmountType;\n      referralAddress?: AddressType | undefined;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    this.assertProxyTon(params.proxyTon);\n\n    const askJettonWalletAddress = await provider\n      .open(JettonMinter.create(params.askJettonAddress))\n      .getWalletAddress(this.address);\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.swapTonToJetton.forwardGasAmount,\n    );\n\n    return await provider.open(params.proxyTon).getTonTransferTxParams({\n      queryId: params.queryId ?? 0,\n      tonAmount: params.offerAmount,\n      destinationAddress: this.address,\n      refundAddress: params.userWalletAddress,\n      forwardPayload,\n      forwardTonAmount,\n    });\n  }\n\n  public async sendSwapTonToJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getSwapTonToJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getSwapTonToJettonTxParams(provider, params);\n\n    return via.send(txParams);\n  }\n\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    return beginCell()\n      .storeUint(DEX_OP_CODES.PROVIDE_LP, 32)\n      .storeAddress(toAddress(params.routerWalletAddress))\n      .storeCoins(BigInt(params.minLpOut))\n      .endCell();\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {bigint | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {bigint | number | string | undefined} params.gasAmount - Optional; Custom transaction gas amount (in nanoTons)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   * @param {Cell | undefined} params.jettonCustomPayload - Optional; custom payload for the jetton transfer message\n   *\n   * @returns {SenderArguments} data required to execute a jetton `provide_lp` transaction\n   */\n  public async getProvideLiquidityJettonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      sendTokenAddress: AddressType;\n      otherTokenAddress: AddressType;\n      sendAmount: AmountType;\n      minLpOut: AmountType;\n      gasAmount?: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n      jettonCustomPayload?: Cell;\n      transferExcessAddress?: AddressType;\n    },\n  ): Promise<SenderArguments> {\n    const [jettonWalletAddress, routerWalletAddress] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.sendTokenAddress))\n        .getWalletAddress(params.userWalletAddress),\n      provider\n        .open(JettonMinter.create(params.otherTokenAddress))\n        .getWalletAddress(this.address),\n    ]);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpJetton.forwardGasAmount,\n    );\n\n    const body = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: this.address,\n      responseDestination:\n        params.transferExcessAddress ?? params.userWalletAddress,\n      customPayload: params.jettonCustomPayload,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const value = BigInt(\n      params.gasAmount ?? this.gasConstants.provideLpJetton.gasAmount,\n    );\n\n    return {\n      to: jettonWalletAddress,\n      value,\n      body,\n    };\n  }\n\n  public async sendProvideLiquidityJetton(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getProvideLiquidityJettonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getProvideLiquidityJettonTxParams(\n      provider,\n      params,\n    );\n\n    return via.send(txParams);\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {PtonV1} params.proxyTon - proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {bigint | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {bigint | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {bigint | number | string | undefined} params.forwardGasAmount - Optional; Custom transaction forward gas amount (in nanoTons)\n   * @param {bigint | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {SenderArguments} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async getProvideLiquidityTonTxParams(\n    provider: ContractProvider,\n    params: {\n      userWalletAddress: AddressType;\n      proxyTon: AbstractPton;\n      otherTokenAddress: AddressType;\n      sendAmount: AmountType;\n      minLpOut: AmountType;\n      forwardGasAmount?: AmountType;\n      queryId?: QueryIdType;\n    },\n  ): Promise<SenderArguments> {\n    this.assertProxyTon(params.proxyTon);\n\n    const routerWalletAddress = await provider\n      .open(JettonMinter.create(params.otherTokenAddress))\n      .getWalletAddress(this.address);\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = BigInt(\n      params.forwardGasAmount ??\n        this.gasConstants.provideLpTon.forwardGasAmount,\n    );\n\n    return await provider.open(params.proxyTon).getTonTransferTxParams({\n      queryId: params.queryId ?? 0,\n      tonAmount: params.sendAmount,\n      destinationAddress: this.address,\n      refundAddress: params.userWalletAddress,\n      forwardPayload,\n      forwardTonAmount,\n    });\n  }\n\n  public async sendProvideLiquidityTon(\n    provider: ContractProvider,\n    via: Sender,\n    params: Parameters<RouterV1[\"getProvideLiquidityTonTxParams\"]>[1],\n  ) {\n    const txParams = await this.getProvideLiquidityTonTxParams(\n      provider,\n      params,\n    );\n\n    return via.send(txParams);\n  }\n\n  private assertProxyTon(proxyTon: AbstractPton) {\n    if (proxyTon.version !== pTON_VERSION.v1) {\n      throw new Errors.UnmatchedPtonVersion({\n        expected: pTON_VERSION.v1,\n        received: proxyTon.version,\n      });\n    }\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   *\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const result = await provider.get(\"get_pool_address\", [\n      {\n        type: \"slice\",\n        cell: beginCell().storeAddress(toAddress(params.token0)).endCell(),\n      },\n      {\n        type: \"slice\",\n        cell: beginCell().storeAddress(toAddress(params.token1)).endCell(),\n      },\n    ]);\n\n    return result.stack.readAddress();\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {Address} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddressByJettonMinters(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const [jetton0WalletAddress, jetton1WalletAddress] = await Promise.all([\n      provider\n        .open(JettonMinter.create(params.token0))\n        .getWalletAddress(this.address),\n      provider\n        .open(JettonMinter.create(params.token1))\n        .getWalletAddress(this.address),\n    ]);\n\n    const poolAddress = await this.getPoolAddress(provider, {\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    return poolAddress;\n  }\n\n  /**\n   * @param {Address | string} params.token0 - The address of the first Jetton minter\n   * @param {Address | string} params.token1 - The address of the second Jetton minter\n   *\n   * @returns {PoolV1} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(\n    provider: ContractProvider,\n    params: {\n      token0: AddressType;\n      token1: AddressType;\n    },\n  ) {\n    const poolAddress = await this.getPoolAddressByJettonMinters(provider, {\n      token0: params.token0,\n      token1: params.token1,\n    });\n\n    return PoolV1.create(poolAddress);\n  }\n\n  /**\n   * @returns current state of the router.\n   */\n  public async getRouterData(provider: ContractProvider) {\n    const result = await provider.get(\"get_router_data\", []);\n\n    return {\n      isLocked: result.stack.readBoolean(),\n      adminAddress: result.stack.readAddress(),\n      tempUpgrade: result.stack.readCell(),\n      poolCode: result.stack.readCell(),\n      jettonLpWalletCode: result.stack.readCell(),\n      lpAccountCode: result.stack.readCell(),\n    };\n  }\n\n  private maybeReferralAddress(referralAddress: AddressType | undefined) {\n    if (!referralAddress) return null;\n\n    const referralAddressParsed = toAddress(referralAddress);\n\n    // ignore hole address as referral address\n    if (referralAddressParsed.equals(HOLE_ADDRESS)) return null;\n\n    return referralAddressParsed;\n  }\n}\n"],"mappings":"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","names":["address"]}