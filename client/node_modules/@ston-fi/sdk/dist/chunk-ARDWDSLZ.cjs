"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;

var _chunkC3OQGEQIcjs = require('./chunk-C3OQGEQI.cjs');


var _chunkIIMQROIVcjs = require('./chunk-IIMQROIV.cjs');


var _chunkZJQ75LD3cjs = require('./chunk-ZJQ75LD3.cjs');


var _chunkQBYZPWDOcjs = require('./chunk-QBYZPWDO.cjs');

// src/contracts/dex/v2_1/LpAccount/LpAccountV2_1.ts



var _ton = require('@ton/ton');
var LpAccountV2_1 = (_class = class _LpAccountV2_1 extends _chunkIIMQROIVcjs.Contract {
  static __initStatic() {this.version = _chunkZJQ75LD3cjs.DEX_VERSION.v2_1}
  static __initStatic2() {this.gasConstants = {
    refund: _ton.toNano.call(void 0, "0.8"),
    directAddLp: _ton.toNano.call(void 0, "0.3"),
    resetGas: _ton.toNano.call(void 0, "0.02")
  }}
  
  constructor(address, { gasConstants, ...options } = {}) {
    super(address, options);
    this.gasConstants = {
      ..._LpAccountV2_1.gasConstants,
      ...gasConstants
    };
  }
  async createRefundBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkC3OQGEQIcjs.DEX_OP_CODES.REFUND_ME, 32).storeUint(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _ => _.queryId]), () => ( 0)), 64).storeMaybeRef(_optionalChain([params, 'optionalAccess', _2 => _2.leftMaybePayload])).storeMaybeRef(_optionalChain([params, 'optionalAccess', _3 => _3.rightMaybePayload])).endCell();
  }
  async getRefundTxParams(provider, params) {
    const to = this.address;
    const body = await this.createRefundBody({
      leftMaybePayload: _optionalChain([params, 'optionalAccess', _4 => _4.leftMaybePayload]),
      rightMaybePayload: _optionalChain([params, 'optionalAccess', _5 => _5.rightMaybePayload]),
      queryId: _optionalChain([params, 'optionalAccess', _6 => _6.queryId])
    });
    const value = BigInt(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _7 => _7.gasAmount]), () => ( this.gasConstants.refund)));
    return { to, value, body };
  }
  async sendRefund(provider, via, params) {
    const txParams = await this.getRefundTxParams(provider, params);
    return via.send(txParams);
  }
  async createDirectAddLiquidityBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkC3OQGEQIcjs.DEX_OP_CODES.DIRECT_ADD_LIQUIDITY, 32).storeUint(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _8 => _8.queryId]), () => ( 0)), 64).storeCoins(BigInt(params.amount0)).storeCoins(BigInt(params.amount1)).storeCoins(BigInt(_nullishCoalesce(params.minimumLpToMint, () => ( 1)))).storeCoins(BigInt(_nullishCoalesce(params.dexCustomPayloadForwardGasAmount, () => ( 0)))).storeAddress(_chunkQBYZPWDOcjs.toAddress.call(void 0, params.userWalletAddress)).storeMaybeRef(params.dexCustomPayload).storeRef(
      _ton.beginCell.call(void 0, ).storeAddress(
        _chunkQBYZPWDOcjs.toAddress.call(void 0, _nullishCoalesce(params.refundAddress, () => ( params.userWalletAddress)))
      ).storeAddress(
        _chunkQBYZPWDOcjs.toAddress.call(void 0, 
          _nullishCoalesce(_nullishCoalesce(params.excessesAddress, () => ( params.refundAddress)), () => ( params.userWalletAddress))
        )
      ).endCell()
    ).endCell();
  }
  async getDirectAddLiquidityTxParams(provider, params) {
    const to = this.address;
    const body = await this.createDirectAddLiquidityBody({
      amount0: params.amount0,
      amount1: params.amount1,
      minimumLpToMint: params.minimumLpToMint,
      userWalletAddress: params.userWalletAddress,
      refundAddress: params.refundAddress,
      excessesAddress: params.excessesAddress,
      dexCustomPayload: params.dexCustomPayload,
      dexCustomPayloadForwardGasAmount: params.dexCustomPayloadForwardGasAmount,
      queryId: params.queryId
    });
    const value = BigInt(_nullishCoalesce(params.gasAmount, () => ( this.gasConstants.directAddLp)));
    return { to, value, body };
  }
  async sendDirectAddLiquidity(provider, via, params) {
    const txParams = await this.getDirectAddLiquidityTxParams(provider, params);
    return via.send(txParams);
  }
  async createResetGasBody(params) {
    return _ton.beginCell.call(void 0, ).storeUint(_chunkC3OQGEQIcjs.DEX_OP_CODES.RESET_GAS, 32).storeUint(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _9 => _9.queryId]), () => ( 0)), 64).endCell();
  }
  async getResetGasTxParams(provider, params) {
    const to = this.address;
    const body = await this.createResetGasBody({
      queryId: _optionalChain([params, 'optionalAccess', _10 => _10.queryId])
    });
    const value = BigInt(_nullishCoalesce(_optionalChain([params, 'optionalAccess', _11 => _11.gasAmount]), () => ( this.gasConstants.resetGas)));
    return { to, value, body };
  }
  async sendResetGas(provider, via, params) {
    const txParams = await this.getResetGasTxParams(provider, params);
    return via.send(txParams);
  }
  async getLpAccountData(provider) {
    const result = await provider.get("get_lp_account_data", []);
    return {
      userAddress: result.stack.readAddress(),
      poolAddress: result.stack.readAddress(),
      amount0: result.stack.readBigNumber(),
      amount1: result.stack.readBigNumber()
    };
  }
}, _class.__initStatic(), _class.__initStatic2(), _class);



exports.LpAccountV2_1 = LpAccountV2_1;
//# sourceMappingURL=chunk-ARDWDSLZ.cjs.map